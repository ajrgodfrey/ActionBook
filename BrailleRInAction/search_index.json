[
["index.html", "BrailleR in Action Preface", " BrailleR in Action A. Jonathan R. Godfrey 2018-08-13 Preface If blind students are to truly gain access to statistical analyses, they will need to be able to successfully complete a course in statistics at university level. To do this, they must learn how the graphical techniques used in the sighted world look and are used. Generation of tactile images can show blind students what a particular graph does in a general sense, but greater understanding will come from generating these graphs as part of an analysis — in the same way it does for sighted students. While sighted students can make use of a number of graphical user interfaces (GUIs), blind students are restricted to use of the command-line mode of operation or typing out an R script in full. One key benefit of the GUI mode of working is the ability to quickly generate basic numerical and graphical analyses. Blind students need to gain the same information as their sighted peers without expending too much additional time and energy. The BrailleR package aims to bridge this gap by delivering the range of analyses commonly found in introductory courses via a reduced set of commands. Once blind students have completed their first course in statistics, they may embark on research at a university, or head out into industry to apply their knowledge. Irrespective of the direction they choose, they will need certainty in being able to independently create graphs for the sighted readers of their work. Creation of tactile images that provide the same representation of the images to be placed in documents can provide a solution, but all too often blind people do not have access to the right software and hardware to generate tactile images for themselves with the immediacy that is required. The BrailleR package aims to provide textual information to the blind user in conjunction with the graph that would be placed in the final report. BrailleR does this by interpreting the object that is implicitly created whenever a graph is created in R. by creating an appropriate and concise text representation of the graph. In summary, this book presents the work included in the BrailleR package that will assist blind students successfully complete an introductory course in statistics when other software options fail them. Many of the functions support workflows that improve the efficiency of blind users at all levels of experience. I’ve tried a few ways to help get blind people using the BrailleR package and needed a place to combine the efforts easily. I don’t yet know if this e-book will turn into anything but a few webpages, but let’s see shall we? Jonathan Godfrey Citation details Please refer interested parties to the online edition of this work at https://R-Resources.massey.ac.nz/BrailleRInAction/ When citing this work, please use the title, author, and date information on this page. The online version has ISBN978-0-473-41495-5 and is preferred for citation over other formats. The epub version has ISBN 978-0-473-41493-1 and pdf version has ISBN 978-0-473-41494-8; these fixed formats were created in October 2017. Copyright information This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. "],
["introduction.html", "Chapter 1 Introduction 1.1 Why will I use the BrailleR package as a novice? 1.2 Why will I use the BrailleR package if I am not a novice? 1.3 References", " Chapter 1 Introduction Access to information is crucial for a blind person’s success in education, but transferring the knowledge about the existence of techniques into actually being able to perform those tasks is what will make that blind person employable. This paper is based on the author’s experiences as a blind academic in statistics who has often been called on for advice by blind students studying statistics and their sighted lecturers wanting to provide the best possible support. Unfortunately, there is little information available in academic journals or the public domain to offer the statistics lecturer who is about to teach a blind student for the first time. At the 2009 Workshop on E-Inclusion in Mathematics and Sciences, I was able to meet other researchers and scientists who are also concerned about the low rate of blind people entering the sciences in a broad sense and the mathematical sciences in particular. (Godfrey 2009) presented my first formalized summary of what I saw as the current state of affairs for blind people taking statistics courses; that work discussed what was possible in theory, but lacked evidence of what was happening in practice. A collaboration with the only other blind person to gain employment as a full-time Lecturer in Statistics led to a more comprehensive review of what we believe is the current state of affairs for blind students learning statistics. (Godfrey and Loots 2015) present a wide range of issues that blind students and their teachers must overcome, often through use of the best software options available today. R (R Core Team 2018) has featured as a key element in my recommendations for teaching statistics to blind students (Godfrey 2009) because it offers the greatest opportunity for meeting the needs of blind users. An invitation to attend the second “Summer University” event was taken up in mid 2011; the purpose of this event was to show blind students and disability support staff from universities what software and hardware is available to improve the success rates of blind students entering the sciences. This was my first direct opportunity to show blind students how R could be used by them, and the relative merit that R has for them over alternative statistical software. I observed blind students working with R and struggling more than I thought was truly necessary. I knew I could do something about it and have spent a lot of time doing so ever since. An R Journal article (Godfrey 2013b) followed which exposed the needs of blind users to the R community and also announced the initial development of the BrailleR package. The BrailleR package is my attempt to help blind students and their lecturers. It is built on functions that I use to work as a lecturer in statistics. It aims to make up for the inability blind users have to work with the same extension tools their sighted peers are using, including the increasing number of graphical user interface (GUI) and integrated development environment (IDE) options. 1.1 Why will I use the BrailleR package as a novice? Blind users will want to use the BrailleR package while they are novice R users, but may also want to continue using some of the tools as their skill levels increase. Each of the following reasons for using the BrailleR package are expanded on by way of examples that go into more detail in subsequent chapters of this text. 1.1.1 BrailleR improves the accessibility of graphical information BrailleR converts standard graphs created by standard R commands into a textual form that can be interpreted by blind students who cannot access the graphs without printing the image to a tactile embosser, or who need the extra text to support any tactile images they do create. At present this is limited to only a few graph types found in base R functionality. An example of a histogram is presented in Chapter 4. 1.1.2 BrailleR helps gain access to the content of the R console BrailleR makes text output (that is visually appealing) more useful for a blind user who is reliant on synthesized speech or braille output to interpret the results. The first example of this kind presented in Chapter 4 shows how the summary statistics for a dataset can be made easier for a screen reader user. 1.1.3 BrailleR includes convenience functions Many analyses get repeated over and over again with different variables. Some people like a graphical user interface (GUI) but none of the GUIs developed for R to date are accessible by screen reader users. BrailleR includes some functions which generate pro forma analyses. When these functions are employed, they generate an HTML document that includes the analysis in an easy to use format. The R commands used to create the analysis are stored in an R script file so that a user can modify the commands if changes are necessary. These functions are introduced in Chapter 7. 1.2 Why will I use the BrailleR package if I am not a novice? I think some of the reasons for using the package while you are a novice R user remain relevant to more-experienced users too, but perhaps the main reason for continuing to use BrailleR is that of efficiency. The convenience functions introduced in Chapter 7 give you a starting point for analyses. Behind those convenience functions was an R markdown file that generated the R script and the HTML document. Getting into markdown is a great idea and will not take you long to learn. BrailleR also includes some tools for helping run your R jobs without running R. Experienced users do this all the time so these tools aren’t really meant for blind users alone, but as blind people often find little inefficiencies tiresome, I’ve incorporated the tools I use for my own efficiency when I think they might prove useful to other blind people. In summary, the BrailleR package is my attempt to help blind students and their lecturers. It is built on functions that I use to work as a lecturer in statistics. It aims to make up for the inability blind users have to work with the same extension tools their sighted peers are using, including the increasing reliance on GUIs and integrated development environment (IDE) options. 1.3 References References "],
["History.html", "Chapter 2 History of the BrailleR Project 2.1 My background 2.2 Getting the BrailleR Project started 2.3 The starting point example 2.4 Why just plain text? 2.5 Exposure of the BrailleR package outside the blind community 2.6 Reviewing statistical software 2.7 Attendance at UseR conferences 2.8 The ongoing work 2.9 Acknowledgements 2.10 References", " Chapter 2 History of the BrailleR Project I am one of only two blind people in the world today who gained employment as full-time lecturers of statistics, that is, teaching statistics classes and doing research in theoretical matters as against applying statistical techniques. For years, I tried to keep my blindness separate from my research but I took some opportunities that came my way and heeded the advice of some colleagues to put more energy into improving the ability of blind students around the world to have greater access to statistics courses and statistical understanding. This document shows you a bit more insight into how I (with the help of some useful collaborations) got the BrailleR package to where it is now. 2.1 My background My adult life has been centred around Massey University, initially as an extramural student and then studying on campus. I have undergraduate degrees in Finance and Operations Research, a Master’s degree in Operations Research and a PhD in Statistics. I was a Graduate Assistant from 1998 to 2002, and then Assistant Lecturer from January 2003 to June 2004 when I became a Lecturer in Statistics. I was promoted to Senior Lecturer in late 2014. While I don’t find it important, I do get asked about the condition that caused my blindness. It is Retinitis Pigmentosa. I do have some light perception, and can make use of it in familiar surroundings for orientation but it has no value to me for reading anything at all. I chose to work with screen reading software when I started university and obtained my first computer because my residual vision at the time was limiting my reading speed. I have therefore operated a computer as a totally blind user throughout my adult life. I did not learn braille until after I completed my PhD. This might seem strange, but there was very little material in a suitable digital format for me to read throughout my student life. Things have changed and I now spend a lot more time reading material and doing programming where the accuracy of braille is absolutely necessary. Braille has now become a very important part of my working life and I have a braille display connected to my computer most of the time. 2.2 Getting the BrailleR Project started I used to keep my research interests separate from my blindness, but I was regularly called upon to discuss how a blind person could study and teach Statistics by many people within New Zealand and occasionally from overseas. In 2009, I attended the Workshop on E-Inclusion in Mathematics and Science (WEIMS09) where I met other people interested in improving the success rates of blind students in the mathematical sciences. My paper was about accessibility of statistics courses, but I did point out the usefulness of R in preference to other tools I had used to that point in time (Godfrey 2009). I discovered that there is room for me to take a leading role in the development of ideas that can help other blind people learn about statistical concepts. I have been invited to all six Summer University events run by the organizers of the International Conference on Computers Helping People (ICCHP), but have been unable to attend twice due to the high cost of transporting me to Europe. I have delivered an introductory workshop on using R at four of these events (Godfrey 2011, 2013a, 2014b, and 2016b). Having observed the attendees at the 2011 Summer University as they came to grips with R, I knew there was more I could do to help them and other blind students. I started work on the BrailleR package (Godfrey et al. 2018) in the second half of 2011 and first proposed it could work for blind users at the Digitisation and E-Inclusion in Mathematics and Science (DEIMS12) workshop held in Tokyo during February 2012 (Godfrey 2012b). I wasn’t to know the value of another talk I gave at DEIMS12 for another two years; this second talk and associated conference paper focused on how I was using Sweave to create accessible statistical reports for me and more beautifully formatted ones for my statistical consulting clients. (Godfrey 2012a). I now know that the groundwork I had done contributed to my desire to present my workflow as a workshop at the 5th Summer University in 2014 (Godfrey 2014d). It also stood me in good stead for the work that followed on the BrailleR package as it developed in late 2014 and early 2015. 2.3 The starting point example The basic graph that has been used for almost every presentation of the BrailleR package is a histogram. There is a more detailed example, but the following commands create a set of numbers that can be kept for further processing once the graph has been created. It is the re-processing of these numbers that leads to the text description that follows. library(BrailleR) ## The BrailleR.View, option is set to FALSE. ## ## Attaching package: &#39;BrailleR&#39; ## The following objects are masked from &#39;package:graphics&#39;: ## ## boxplot, hist ## The following object is masked from &#39;package:utils&#39;: ## ## history ## The following objects are masked from &#39;package:base&#39;: ## ## grep, gsub x=rnorm(1000) VI(hist(x)) Figure 2.1: A histogram of 1000 random values from a normal distribution ## This is a histogram, with the title: Histogram of x ## &quot;x&quot; is marked on the x-axis. ## Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, and 3 ## There are a total of 1000 elements for this variable. ## Tick marks for the y-axis are at: 0, 50, 100, 150, and 200 ## It has 14 bins with equal widths, starting at -3.5 and ending at 3.5 . ## The mids and counts for the bins are: ## mid = -3.25 count = 2 ## mid = -2.75 count = 4 ## mid = -2.25 count = 12 ## mid = -1.75 count = 46 ## mid = -1.25 count = 84 ## mid = -0.75 count = 163 ## mid = -0.25 count = 193 ## mid = 0.25 count = 180 ## mid = 0.75 count = 153 ## mid = 1.25 count = 95 ## mid = 1.75 count = 41 ## mid = 2.25 count = 19 ## mid = 2.75 count = 7 ## mid = 3.25 count = 1 This first example showed me what was possible if only I could get a few things sorted out. All histograms are created by a function that stores the results (both numeric and text details) and calls this stored set of values a “histogram”. The main issue is that storing the set of details is not consistent in R, nor is the fact that the stored object gets given a “class” to tell me what type of object it is. This problem haunted me for quite some time because I was talking to the wrong people about the problem; it was time to find people that held the solution instead of talking to the people that would benefit if a solution was found. 2.4 Why just plain text? The first initiative of BrailleR was to turn information presented in a visual medium into a medium that is simple to work with, efficient, and complementary to the skill set of as wide a group of blind people as possible. With this in mind, a plain text solution for gaining access to visual information was favoured above tactile images as there is no need for any additional adaptive technology (hardware or software) over that used for the blind person’s other work. Information presented in text is readable in braille or heard via synthetic speech, and is therefore only limited to the user’s skill set. Other research projects are progressing the creation of tactile images that replace the printed graphics sighted people deal with all the time in statistical work. Tactile images do have a role to play in educating blind people and providing them with access to information, but their greatest drawback remains their lack of immediacy. Rendering a graphic into a master file complete with braille labels, and then producing this for consumption are tasks receiving much attention, but the value for such efforts is probably greatest for situations where one master can be used to create multiple copies for wider consumption such as the conversion of textbooks into braille. Some preliminary investigations into the ability to create tactile image versions of graphs created in R have been made as part of the wider BrailleR Project. Under a sighted paradigm, many graphs in statistical work are developed for one-time use and discarded almost immediately. It may be some time until the effectiveness of tactile image hardware and software is ready to deliver this outcome for all blind users of R; in the meantime, we must find ways of gaining access to the graphical information without reliance on another person’s ability to translate the visual medium into something more useful for us. We must also acknowledge here that the number of blind people with their own tactile image hardware and software is regrettably low. Even though it is possible to directly export a graph created in R to an embosser, use of this practice is not yet commonplace. Perhaps we can look forward to the time when most blind people can have access to a refreshable tactile display that can display two-dimensional images that compare with the best that is possible in hard copy today. Sonification is considered by many to be an alternative to production of tactile images for a blind audience. Work on sonifying statistical graphs is being considered, but is at present best described as experimental. Several concerns must be overcome before sonification can be claimed a truly useful method for interpretting data. There is an assumption made frequently by correspondents with this author that lack of vision implies a blind person has superior aural ability . This may be true for some blind people, but it is not universally true. We must be sure that the interpretation gained through sound is comparable to the interpretation that a graph in visual form would convey. Proponents of sonification often suggest that sound provides a different interpretation to a visual display. If they are correct, then sonification cannot be a true alternative to a visual graph. The same, of course, can be said for the difference between the interpretation obtained through touching tactile images. In both cases, the solution for blind users must be that the visual representation can be converted to a useful format when blind users need it, without the assistance of a sighted person to check the validity of the outcome. 2.5 Exposure of the BrailleR package outside the blind community It was obvious to me that getting the word out to the masses about the usefulness of R for blind students and professionals was crucial. I started to compile my notes built up from various posts made to email groups and individuals over the years, as well as the lessons I learned from attendance at the 2nd Summer University event. This led to the eventual publication of my findings in (Godfrey 2013b). I know that this was a worthwhile task because it was read by teachers of blind students who were already using R for their courses. One such person tested R and a screen reader and managed to find a solution to a problem posed in Godfrey (2013b) which led to an addendum (Godfrey and Erhardt 2014). I presented some of my work via a poster (Godfrey 2013c) at the NZ Statistical Association conference in Hamilton during November 2013. This ‘poster’ presentation was developed as a multimedia presentation so that the audience could observe video footage, handle tactile images and be able to talk with me about the BrailleR Project. The plan to get talking with people instead of talking at them worked and I started a really useful collaboration with Paul Murrell from the University of Auckland. His major contributions didn’t feature in the BrailleR package for some time, but we’re making some really nice progress. Paul is an expert in graphics, especially their creation and manipulation in R. Our discussions about graphics has yielded a few titbits for my own work that have been tested for the package. We’ve been working on how to make scalable vector graphics that can be augmented to offer blind users greater interactivity and therefore hopefully greater understanding (see Godfrey and Murrell 2016). 2.6 Reviewing statistical software I have been asked about the use of R in preference to other statistical software by many blind students, their support staff, and their teachers. Eventually I joined forces with the only other blind person to gain employment as a lecturer of statistics (Theodor Loots, University of Pretoria) to compare the most commonly used statistical software for its accessibility (Godfrey and Loots 2014). I summarised this paper at the 5th Summer University event (Godfrey 2014a), and offered a similar presentation at the 6th Summer University event (Godfrey 2016a) with a few updates. It is important to keep abreast of developments, because the statistical software changes, and so does the screen reading software that gives us access to the mainstream statistical software. 2.7 Attendance at UseR conferences On my way to the 5th Summer University event, I managed to attend the principal conference for R users (UseR!2014) in Los Angeles where I presented my findings (Godfrey 2014c). Perhaps the most valuable outcome of this conference was the ability to attend a tutorial on use of the knitr package (Xie 2018) and then talk to its author, Yihui Xie. I’d already seen the knitr package before attending UseR!2014 and implemented it for some of my teaching material by updating the Sweave documents already in use. The real value came in realising what I could probably do if I used R markdown to do a few things I had found very hard using the Sweave way of working. More specifically, generating an R markdown file (Rmd) from an R script was much easier than generating a Sweave file (Rnw). Writing the convenience functions for the BrailleR package started to look very achievable at this point, and so work began. I dug out some old work that wasn’t fit for sharing and converted it to the markdown way of working. There has been sufficient progress in the BrailleR Project that I presented it at UseR!2015 (Godfrey 2015). In 2016, I presented my findings on writing (and therefore reading) R markdown documents for (and by) blind users (Godfrey and Bilton 2016). 2.8 The ongoing work The introduction of R markdown to the BrailleR package made a huge difference. I’ve been able to write enough example code that once I found a friendly postgraduate student (Timothy Bilton) to put some time into it, we’ve managed to add more convenience functionality. Timothy improved some of my earlier work and tried a few things of his own. This left me with the time to add increased functionality for helping blind users get into markdown for themselves. One of my irritations of working with markdown is that everyone else seems to write markdown and check their findings using RStudio (RStudio 2018), which remains inaccessible for me and other screen reader users. I took an old experiment where I wrote an accessible text editor in wxPython, and with the help of a postgraduate student from Computer Science (James Curtis) we’ve modified it to process Rmd files. The WriteR application is now beyond experimental but there is still more to do on making it truly useful (Godfrey and Curtis 2016). In 2018, I received a great deal of assistance from Marshall Flax who was able to help develop WriteR into a tool that could be very useful to blind people wishing to write and process R markdown files. 2.9 Acknowledgements Contributions to the BrailleR Project are welcome from anyone who has an interest. I will acknowledge assistance in chronological order of the contributions I have received thus far. Greg Snow was the first person to assist when he gave me copies of the original R code and help files for the R2txt functions that were part of his TeachingDemos package (Snow 2016). The Lions clubs of Karlsruhe supported my attendance at the 3rd Summer University event in 2013. This gave me the first opportunity to put the package in front of an audience that I hope will gain from the package’s existence. I’ve already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, James Curtis, and Marshall Flax. I also need to acknowledge the value of attending the Summer University events. I gain so much from my interactions with the students who attend, the other workshop leaders who give me feedback, and the other professionals who assist blind students in their own countries. 2.10 References References "],
["GettingStarted.html", "Chapter 3 Getting started with BrailleR 3.1 Accessibility of statistical software 3.2 Accessibility of R 3.3 Installing the BrailleR package 3.4 What else do you need? 3.5 BrailleR commands used in this chapter 3.6 References", " Chapter 3 Getting started with BrailleR The BrailleR package has been created for the benefit of blind people wishing to get more out of R than it already offers — which is actually quite a lot! 3.1 Accessibility of statistical software A description of what makes statistical software accessible to the blind was given by (Godfrey and Loots 2014). Many of the problems blind people face are a consequence of the failure of the specialist screen reading software we use to interact with graphical user interfaces. Many software applications are making use of graphics when once the information would be presented in text form with an accompanying graph. — SPSS (Inc. 2012) is an example of this, and to a lesser extent so is the standard edition of Minitab (Minitab Inc. 2012). The output from Minitab Express (Minitab Inc. 2014) is a prime example of the worst possible presentation of information that was originally text; this product generates graphics that include text which is not readable by a blind person for all of its statistical output. The speech output software used by blind people can only interpret information that is text. As a guide, if the individual text in a window cannot be highlighted using the keyboard and not the mouse, then it is likely that this text will not be read for the blind user. It is true that some add-on packages for R also generate unreadable output, but as illustrated below, this is less of an issue than for software like SPSS or Minitab. (Godfrey and Loots 2014) gave more detailed scrutiny of R, SAS (SAS Institute Inc. 2010) , SPSS, and Minitab. Of these four applications, R and SAS were clearly superior to SPSS and the standard edition of Minitab. Some software applications have retained their historical links to the days when graphs and tables were rendered in well controlled monospace fonts — Minitab for example. In such applications the user may still be able to produce an ASCII graphic instead of the more commonly used high resolution graphs expected of today’s software (and user). In contrast, SAS and SPSS can use HTML to present information in well-formatted tables. These output windows are preferred by blind users over the graph window displays but sometimes the amount of information is not easily understood. Presentation of output is often read by eye in a vertical direction, while speech output software will read line by line. Take for example, a multiple regression where the sighted reader may scan down the list of \\(p\\)~values in the right hand column; the same information being read aloud in line by line style could prove quite difficult to interpret. Blind users can use combinations of keys to move around HTML tables to speed up this process and avoid reading the intervening columns of output. While SPSS and SAS can deliver formatted HTML as a matter of course, R users must resort to the add-on packages, many of which are available on CRAN. 3.2 Accessibility of R (Godfrey 2013b) documented the ability to use R almost immediately after installation; only one minor change is recommended and can be achieved in less than a minute even when explained via email or a telephone call. For users of the Windows operating system, up until Windows XP, I always recommended running R in a terminal window instead of the GUI; the shortcut placed on the Windows desktop would then need to be pointed to Rterm.exe instead of Rgui.exe. Macintosh and Linux users are operational with no special actions required. Users of Windows Vista or Windows 7 did have an additional challenge of what appeared to be the screen locking up, or more exactly, the screen reader software “losing focus” in the R terminal window. The solution for this problem, as documented in (Godfrey and Erhardt 2014), was to hit the Alt key. Blind users now need to compare the combinations of screen reader and the terminal versus the GUI. The decision should be made by the individual user after some experimentation; their decision may depend on the skill level they have with their prefered screen reader and should be revisited at a later date. Blind students attending the R workshop at the 2011 Summer University, held in the Czech Republic, were able to set up R for use in a classroom setting on their own machines. This included a variety of operating systems and adaptive technology (hardware and software for blind people). Similar events were held in 2013 and 2014 but most attendees used computers supplied by the host organizing committees. Many attendees have made contact when issues have arisen, but none of the issues relate to the installation of R or its interactions with the particular hardware or software being used. I am confident that anyone intending to undertake use of any statistical software will be able to get R working with their screen reader. 3.3 Installing the BrailleR package To use the functionality of the BrailleR package you need to have it installed. The package has several dependencies so installation from the CRAN repository is recommended. This would be done by issuing the following two commands in an R session: chooseCRANmirror(ind=1) install.packages(&quot;BrailleR&quot;) Note that the first and last letters of BrailleR are capitalised. This is important in R, but is also useful for screen reading software which will then give audibly different feedback, as compared to what a screen reader user hears from the lower case text “brailler”. If for some reason you have difficulty with the above commands, you can install the BrailleR package using a zip file version available from a CRAN repository or the latest version on GitHub. From time to time, you should check that you are using the most recent version of the BrailleR package. You can update all installed packages using the commands: chooseCRANmirror(ind=1) update.packages(ask=FALSE) Once you’ve got the package installed, you still need to get it running in your current R session by issuing one last command. When you issue the first of the following lines, the package start messages will also appear. library(BrailleR) You’re ready to go! 3.3.1 Some initial setting up instructions When you first use the library(BrailleR) command, you will see some start up messages and a question. The rules of R packages include not writing to the user’s hard drive without expressly asking them for permission to do so. If you do not want a folder for your BrailleR files then use the temporary folder which will be removed when you end your R session. This will mean you need to answer the question over the location of the MyBrailleR folder next time you issue the library(BrailleR) command though. The welcome message from BrailleR suggests you issue the GetGoing() command. This will ask you a few questions that will help personalise your use of the BrailleR package. We will see how to alter these settings in Chapter 8 later so don’t panic if you don’t do it all right the first time. You can re-issue the GetGoing() command again at any time. The book you are reading now can be reached from your R session by issuing the command BrailleRInAction(). That might seem a bit much, but do remember you can use tab completion to avoid typing the whole command name out in full. You will probably need no more than B, r, a, then tab (which adds the rest of BrailleR), then I and one last tab; add the opening and closing parentheses and press the Enter key. This will open the front page of the book in your browser. A similar command, BrailleRHome(), will open the BrailleR Project home page. You will need to be careful with upper versus lower case when entering commands. Note that there are often capitalised letters in the middle of BrailleR commands. This is known as “camel case” and it works well for screen reader users. It is all too easy to feel you’re doing it on your own, which even the most accomplished people have experienced. I put the ThankYou() command in the BrailleR package so that it would be easy to send me a message to tell me about your experiences as a blind person using R or to ask for help; it starts an email message to me. I’m not the only blind person out there using R, and many of us are on an email list so that we can share ideas and solutions for problems, many of which are specific to blind users. The JoinBlindRUG() command will start the email needed to join the BlindRUG email list. 3.4 What else do you need? You obviously have R installed or an intention to do so soon if you are reading this document. Aside from R and the add-on packages that BrailleR needs, there are no other software requirements. There are several optional software installations that could make life easier if they are installed before you need them. In order of necessity, they are: 3.4.1 The document converter — pandoc BrailleR requires the very useful file converter called pandoc. Get it from the pandoc download page 3.4.2 The principal integrated development environment — RStudio It is a good idea to install RStudio, even if you can’t actually use it as a blind person using screen reading software. The reason is that RStudio installs a few other useful tools that we will make use of by other means. Get it from the RStudio download page 3.4.3 One programming language — Python WriteR is a simple text editor written in wxPython that needs Python and wxPython. Unfortunately, they require separate downloads. You do not need this editor so do not install Python unless you are really keen. Windows users can obtain an executable file by issuing GetWriteR() once the BrailleR package has been successfully installed. More on this in Chapter 10. 3.5 BrailleR commands used in this chapter The only BrailleR command actually recommended in this chapter was GetGoing(). You might find it useful to use BrailleRHome() and BrailleRInAction() from time to time, but you’re already reading the book that the second of these commands opens. The ThankYou() and JoinBlindRUG() commands should be used when you want to connect with me, or other blind R users. At this stage it is recommended that you install any additional software manually when it is required. 3.6 References References "],
["VI.html", "Chapter 4 Some basic examples 4.1 Accessibility of graphics in statistical software 4.2 Histograms 4.3 Basic numerical summaries 4.4 BrailleR commands used in this chapter", " Chapter 4 Some basic examples This chapter presents some examples of text output generated by the VI() command of the BrailleR package. These examples generate output that is displayed in the R session just like any output from standard R commands. Please note however that not all VI() commands behave in this fashion; some more advanced uses of VI() are discussed in a later chapter. You will need the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the command library(BrailleR) now. 4.1 Accessibility of graphics in statistical software Access to graphical representations of information from mathematical or statistical software is quite limited, and therefore limits the blind user’s capacity. To this author’s knowledge, no mathematical or statistical software has the capability of directly linking to any hardware or software solutions that make the information presented in graphs immediately available. The scalable vector graphic (SVG) format can be used to present a graphic with text embedded into the file for creating access for a blind user (Bulatov and Gardner 2004; Gardner and Bulatov 2010). Only a small number of statistical software applications have the capacity to create SVG files, but this capacity does not in itself create access because the text that makes them accessible must be added somehow; generally this is a manual process. The World Wide Web Consortium has a recommendation on the use of SVGs in web content (Dengler et al. 2011) and a number of add-on packages for R make use of SVG because of the opportunity to enrich a graphic’s interactivity in webpages; see (Murrell and Potter 2014) for a more detailed discussion of these packages and their functionality. Of particular note is that there are different ways to create an SVG and care must be taken if the maximum accessibility for blind users is ever to be achieved. In R, a graph can be saved as an SVG using the svg() command, but this approach uses the Cairo SVG format; this has the unfortunate outcome that text is not always preserved as a string, and some shapes are represented by an unstructured set of straight lines (Gardner and Bulatov 2010). Retention of text as strings is crucial if modifications such as changing the font of any text to the braille font of a user’s choosing is to be managed easily. Use of the gridSVG package (Murrell and Potter 2014) does lead to creation of SVG files that do keep strings of text intact and a hierarchy of graphical elements. These SVG files are more easily modified to create accessibility for blind users that have the technology to interpret them (Gardner and Bulatov 2010). Any graph created in R using functions from the graphics package will need to be converted to the grid package system for generating graphics through use of the gridGraphics (Murrell 2015) package before they are exported in SVG format. Existence of the gridSVG and gridGraphics packages means that it should be possible to automate the creation and addition of the necessary text information to the SVG so that the need for human intervention is minimised. Add-on scripts for screen reader software, such as JAWS (Freedom Scientific 2018), that attempt to interpret the graphs created by common spreadsheet software has been tried in the past. One major problem that results from the creation of these add-on scripts is that of maintenance; unfortunately, the add-on scripts for screen reader software support of spreadsheet applications has not kept pace with the developments of those applications sufficiently enough to give blind people access to the full range of graphs. Sporadic effort has been made at providing access to statistical software through the creation of add-on scripts for screen readers, but little effort was ever given to creating access to the content of graphics. It is unfortunate that these have also not been sufficiently maintained. In this respect the use of R or SAS currently hold an advantage over other commonly used software (notably SPSS and Minitab) for the blind user because no additional scripts for the screen reading software are required. (Godfrey and Loots 2014). R and SAS also work well with the open source screen reader called NVDA (NVDA Team 2018). In conclusion, it seems that until such time as adaptive technology for creating immediate access via tactile images is commonly available, other solutions will continue to be relevant. In fact, even once the immediacy issue is overcome, there will be a place for solutions such as the BrailleR package as a complementary solution rather than a substitute. At each of the Summer University and Blind Science Conference events I have shown students that they could use R to gain access to graphed information in a manner almost unparalleled by other statistical software — the obvious exception to this rule is S-PLUS (Insightful Corp. 2003). This advantage comes from the fact that the S language, on which R is built, implicitly stores the data needed to create many graphs, and this data can be assigned to an object for further manipulation. This is not true for graphs created using the ubiquitous plot() function however, and many other plotting functions that explicitly return a NULL object. We will first look at a graph object that can be explicitly stored. 4.2 Histograms The first and most commonly used example demonstrating the value of the BrailleR package to a blind user is the creation of a histogram. For example, a sighted user wanting a histogram of 1000 randomly chosen values from a standard normal distribution would type Y = rnorm(1000) HIST = hist(Y) Figure 2.1: A histogram of 1000 random values from a normal distribution A simple way for blind users to access the information used to create a graph is to ask R to print the object, using the print() command. print(HIST) $breaks [1] -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 [15] 3.5 $counts [1] 1 1 14 51 90 163 188 190 136 99 40 21 4 2 $density [1] 0.002 0.002 0.028 0.102 0.180 0.326 0.376 0.380 0.272 0.198 0.080 [12] 0.042 0.008 0.004 $mids [1] -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 [12] 2.25 2.75 3.25 $xname [1] &quot;Y&quot; $equidist [1] TRUE $ExtraArgs $ExtraArgs$main [1] &quot;Histogram of Y&quot; $ExtraArgs$xlab [1] &quot;Y&quot; $ExtraArgs$ylab [1] &quot;Frequency&quot; $ExtraArgs$sub [1] &quot;&quot; $NBars [1] 14 $par $par$xaxp [1] -3 3 6 $par$yaxp [1] 0 150 3 $xTicks [1] -3 -2 -1 0 1 2 3 $yTicks [1] 0 50 100 150 attr(,&quot;class&quot;) [1] &quot;Augmented&quot; &quot;histogram&quot; The print() command can be wrapped around the hist() command which avoids explicit storage of the object, but still creates the histogram. This approach can be taken for many graph types where the option of suppressing the graph is not available. The hist command gives the user an explicit way of generating the information a blind user may want. Similar functionality exists using the boxplot.stats() command for example. Such workhorse functionality is useful but not well-documented. Given the user has stored the output from the hist() function in an object, they can interpret the text to gain some idea of what appears in the histogram. As the object is designed for compatibility and flexibility, not all of the printed information is relevant to the end user however so some further education or perhaps further processing is still required. This approach is workable but not elegant. On some occasions the data structure listed is just a list of the actual data itself and is therefore not giving blind users the same information as sighted users get from a graph. Blind users need some sort of summarisation tool to replace the graph, and in many instances, are unlikely to have the skill to develop a sound statistical solution for themselves. It is also reliant on users knowing what the various elements printed out are, and how they link to the visual object created for the sighted world. The initial aim of the BrailleR package was to take the information created by various functions in R and create a text printout that reduces the amount of information that needs to be processed by blind users. In cases like that for the histogram example just introduced, this is a fairly simple task. For other situations, some further work needs to be done so that the textual information is a useful summary of the graphical information without crossing over the line of interpreting the information for the user. So let’s see what BrailleR is going to offer a blind user instead of the verbose printout seen above. VI(HIST) This is a histogram, with the title: Histogram of Y &quot;Y&quot; is marked on the x-axis. Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, and 3 There are a total of 1000 elements for this variable. Tick marks for the y-axis are at: 0, 50, 100, and 150 It has 14 bins with equal widths, starting at -3.5 and ending at 3.5 . The mids and counts for the bins are: mid = -3.25 count = 1 mid = -2.75 count = 1 mid = -2.25 count = 14 mid = -1.75 count = 51 mid = -1.25 count = 90 mid = -0.75 count = 163 mid = -0.25 count = 188 mid = 0.25 count = 190 mid = 0.75 count = 136 mid = 1.25 count = 99 mid = 1.75 count = 40 mid = 2.25 count = 21 mid = 2.75 count = 4 mid = 3.25 count = 2 The VI() command actually calls the VI.histogram() command because we know it is a histogram that was generated by hist() above. 4.2.1 Important features The commands used above explicitly stored the histogram. A blind user could use VI(hist(y)) instead to get the same outcome. In that case, the VI() command would add to the impact of issuing the hist() command because the graphic is still generated for the sighted audience. The blind user can then read from the text description so that they can interpret the information that the histogram offers the sighted world. 4.2.2 Warning The VI() function is partially reliant on the use of the hist() function that is included in the BrailleR package. If a histogram is created using a command that directly links to the original hist() command found in the graphics package, then the VI() command’s output will not be as useful to the blind user. This mainly affects the presentation of the title and axis labels; it should not affect the details of the counts etc. within the histogram itself. This behaviour could arise if the histogram is sought indirectly. If for example, a function offers (as a side effect) to create a histogram, the author of the function may have explicitly stated use of the hist() function from the graphics package using graphics::hist() instead of hist(). Use of graphics::hist() will bypass the BrailleR::hist() function that the VI() command needs. This should not create error messages, but may result in some strange and possibly undesirable output. 4.3 Basic numerical summaries The standard presentation of a summary of a data frame where each variable is given its own column is difficult for a screen reader user to read as the processing of information is done line by line. For example: summary(airquality) Ozone Solar.R Wind Temp Min. : 1.00 Min. : 7.0 Min. : 1.700 Min. :56.00 1st Qu.: 18.00 1st Qu.:115.8 1st Qu.: 7.400 1st Qu.:72.00 Median : 31.50 Median :205.0 Median : 9.700 Median :79.00 Mean : 42.13 Mean :185.9 Mean : 9.958 Mean :77.88 3rd Qu.: 63.25 3rd Qu.:258.8 3rd Qu.:11.500 3rd Qu.:85.00 Max. :168.00 Max. :334.0 Max. :20.700 Max. :97.00 NA&#39;s :37 NA&#39;s :7 Month Day Min. :5.000 Min. : 1.0 1st Qu.:6.000 1st Qu.: 8.0 Median :7.000 Median :16.0 Mean :6.993 Mean :15.8 3rd Qu.:8.000 3rd Qu.:23.0 Max. :9.000 Max. :31.0 The VI() command actually calls the VI.data.frame() command. It then processes each variable one by one so that the results are printed variable by variable instead of summary statistic by summary statistic. For example: VI(airquality) The summary of each variable is Ozone: Min. 1 1st Qu. 18 Median 31.5 Mean 42.1293103448276 3rd Qu. 63.25 Max. 168 NA&#39;s 37 Solar.R: Min. 7 1st Qu. 115.75 Median 205 Mean 185.931506849315 3rd Qu. 258.75 Max. 334 NA&#39;s 7 Wind: Min. 1.7 1st Qu. 7.4 Median 9.7 Mean 9.95751633986928 3rd Qu. 11.5 Max. 20.7 Temp: Min. 56 1st Qu. 72 Median 79 Mean 77.8823529411765 3rd Qu. 85 Max. 97 Month: Min. 5 1st Qu. 6 Median 7 Mean 6.99346405228758 3rd Qu. 8 Max. 9 Day: Min. 1 1st Qu. 8 Median 16 Mean 15.8039215686275 3rd Qu. 23 Max. 31 4.3.1 Important features Note that in this case, the blind user could choose to present the summary of each variable as generated by the VI() command, or the output from the standard summary() command. There is no difference in the information that is ultimately presented in this case. 4.4 BrailleR commands used in this chapter The only explicit command from the BrailleR package used in this chapter was the VI() command. References "],
["NewGraphs.html", "Chapter 5 New BrailleR commands for making and interpreting basic graphs 5.1 What’s in a graph? 5.2 Background 5.3 Example: A histogram 5.4 Scatter plots 5.5 BrailleR commands used in this chapter", " Chapter 5 New BrailleR commands for making and interpreting basic graphs This chapter introduces two types of new commands found in the BrailleR package. There are several commands to help a blind user know what is included in a graph, starting with a tool to help “know” what is displayed in an otherwise inaccessible graphics device window. The other commands introduced in this chapter are substitutes for functions found in the base distribution of R. You can jump ahead to the examples, but there is some theory needed to explain how the BrailleR package does the extra work it does, and why we need to use these substitute commands. You will need the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the command library(BrailleR) now. 5.1 What’s in a graph? A challenge for many blind people is to understand the way a scatter plot shows a relationship between two variables. In a theoretical sense they can learn that a scatter plot does show a relationship, outliers etc. but the ability to construct a scatter plot for themselves and then interpret it in a similar way to their sighted peers is not possible unless they have direct access to a tactile image embosser. Such access is not immediate as embossers are not portable. Although efforts to create tools that can be used by blind people who do not have access to an embosser are not new (Calder et al. 2006), more recent developments have tended to focus on use of touch screen technologies. To this author’s knowledge, no comprehensive solution exists to meet the need for blind users to independently create statistical graphs with confidence or to modify them without starting all over again. Solutions for giving blind people access (in a general sense) are often aimed at providing an exact replica of what the sighted person can see. A statistical graph can exist on two levels: First, the exact detail of individual elements that are plotted in the graph, and second, the combined effect this collection of elements conveys. As we look at the various graphs being produced in any analysis, we need to think about which of these activities is being done by the sighted world as they consume the content. If we do not understand what the consumer is doing, we cannot hope to provide an appropriate graph for them; to be a producer of a graph, you must also be a consumer of it, albeit temporarily. The solutions offered to blind users by BrailleR try to keep this ethos in mind. 5.2 Background In Chapter 4, we saw creation of a histogram using the hist() command. The hist() command used for many years is found in the graphics package and has its own plot() command called plot.histogram() as well. This plot() command is actually a family of commands that all start withplot.*() where the star is replaced by the type of object that is being plotted. We use this plot() command all the time to give us plots for different reasons. When we fit a regression model, we need to create various plots of the residuals and it is done using plot() which actually employs plot.lm() in the background to do the work. The family of commands are referred to as “methods” and the types of objects being worked on are called “classes”. We need a little more background before diving into the various new commands BrailleR offers. 5.2.1 Methods and classes Development of the BrailleR Package and discussion of its opportunities is totally reliant on two of the structures used in the S language. These are “methods” and “classes”. In brief, a set of commands that perform a similar task on a selection of different classes is a “method”. Methods and classes are important ideas because we can write a method function that says how we want an object with a stated class to be processed. Methods need classes, and we wouldn’t need classes if we didn’t hope to use methods. When we create a histogram with the hist() command we can store an object of class “histogram”, and when we create a regression model using lm() we create an object of class “lm”. The hist() command does create an object with the class attribute set to histogram, but only one specific function exists for this class, that being the plot.histogram() function to plot the histogram. Sighted users don’t need an explicit print function for a histogram, nor does this summary graph need further summarisation. Tasks that warrant a method being written for each of a variety of classes include: we might need a function to print the object out in an easy to use fashion. THis happens all the time, but most R users just take it for granted that the output looks the way it does. In fact, the output is formatted behind the scenes. we may need to plot the results in a graph. A simple plot() command does all sorts of different things. Novice users just watch the magic without asking how it happens. we may need to create a different kind of object that summarizes the original object in some way. This is already done using the summary() function, but that simple summary() command is actually a set of functions for different classes. These are just three tasks common to objects of many classes. There is nothing stopping any R user from writing a method to handle a variety of classes or adding to the methods that already exist. A complete method will have a base function that informs the software that there is a family of functions written for different classes, and that a method has been written for the default action, which is applied if no specific method exists for a class. For example, the print method includes specific functions: print(), print.default(), print.matrix(), and many more. If we issue the command print(x), and we know that x is a matrix, the print() method will employ the print.matrix() function to display the matrix. The example given in Chapterthat printed the results of the histogram object used the print.default() function as there is no print.histogram() function in existence. Many R commands do lead to an object being created with a class attribute being explicitly stated, sometimes it is more implicit, but all too commonly no class attribute is established at all. The vast majority of statistical models set a class for the model being stored. There are some quite uninformative classes set as well. Assigning a class to an object means that we can write functions that relate to all objects of a particular class using a general approach. A class therefore needs to be defined for a set of objects that are going to be homogeneous in their structure. Data is usually stored with a specified class attribute, such as a time series with class “ts” for example. We will generate different results from employing methods if we have correctly specified the data using a class attribute. We can also modify a data object’s class, using commands like as.tx() to turn a vector of numbers into a time series if we need to do so to get the desired outcome. A data.frame is itself of class “data.frame”, a matrix is of class “matrix”, but rather confusingly, a vector is not of class “vector”. Vectors are assigned class attributes that depend on the type of data being stored, being “integer”, “numeric”, “logical”, “character”, etc. As previously stated, the usefulness of methods is dependent on the use of classes being employed when objects are created. The original hist() command does specify the resulting histogram to have a class, but there is no explicit print.histogram() method at this time. In addition, not all objects are given a class so the default method must be constructed carefully. There are actually only a few basic data structures to work with, the easiest and most common of which is called a “list”. The results of applying the print() command to a histogram shown in Chapter 4, couldn’t use the non-existent print.histogram() function so it used the print.default() method instead. The content of the object is stored as a “list”, but note the last element of the list that states the class of the object. Adding this extra attribute to the data object is a minor matter that has very powerful consequences! 5.2.2 Who cares about classes anyway? It is a reasonable question to ask. BrailleR cares because the functions written such as the VI() command used throughout Chapter 4 is actually a family of commands. The beginnings of the BrailleR Project were formed on the idea of writing a method that would provide the summarised text version of the graph object created. To this end, a method was started with the functions: VI(), VI.default(), and VI.histogram() in order to demonstrate the approach. The VI() commands called actually refered to the VI.histogram() and VI.data.frame() commands to generate output that is sensitive to the object of interest. So for the VI() command to do the processing necessary to extract the information that is pushed into a graphic or textual output, we need to know what kind of object was being created. For the examples shown in Chapter 4, that was done with the standard R commands used when creating the histogram and the data.frame we used. Well that’s almost true. The standard hist() command from the base distribution of R does assign the class “histogram” to the stored object, but it doesn’t have all the necessary information in it to replicate a plotted histogram. The solution is to create a new hist() command in the BrailleR package that does all the work of the original function and does add the details we want to help describe the histogram being plotted. 5.3 Example: A histogram One of the easiest ways to demonstrate code snippets is to include them in the help documentation of the function. Running these examples is then possible using the example() command. In this example, we see that use of the original hist() from the graphics package yields the same graph as the BrailleR package version, but that the additional text for such items as titles and axis labelling used in the text description are only added by BrailleR::hist(). Running the command, example(hist) command will give you the following: &gt; x = rnorm(1000) &gt; MyHist = graphics::hist(x, xlab = &quot;random normal values&quot;, + main = &quot;Example histogram (graphics package)&quot;) Figure 5.1: testing examples &gt; MyHist $breaks [1] -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 [15] 3.5 $counts [1] 1 8 15 41 99 154 218 173 137 99 29 21 3 2 $density [1] 0.002 0.016 0.030 0.082 0.198 0.308 0.436 0.346 0.274 0.198 0.058 [12] 0.042 0.006 0.004 $mids [1] -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 [12] 2.25 2.75 3.25 $xname [1] &quot;x&quot; $equidist [1] TRUE attr(,&quot;class&quot;) [1] &quot;histogram&quot; &gt; MyHist = hist(x, xlab = &quot;random normal values&quot;, main = &quot;Example histogram (BrailleR package)&quot;) Figure 5.1: testing examples &gt; MyHist $breaks [1] -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 [15] 3.5 $counts [1] 1 8 15 41 99 154 218 173 137 99 29 21 3 2 $density [1] 0.002 0.016 0.030 0.082 0.198 0.308 0.436 0.346 0.274 0.198 0.058 [12] 0.042 0.006 0.004 $mids [1] -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 [12] 2.25 2.75 3.25 $xname [1] &quot;x&quot; $equidist [1] TRUE $main [1] &quot;Example histogram (BrailleR package)&quot; $xlab [1] &quot;random normal values&quot; $ExtraArgs $ExtraArgs$main [1] &quot;Histogram of x&quot; $ExtraArgs$xlab [1] &quot;x&quot; $ExtraArgs$ylab [1] &quot;Frequency&quot; $ExtraArgs$sub [1] &quot;&quot; $NBars [1] 14 $par $par$xaxp [1] -3 3 6 $par$yaxp [1] 0 200 4 $xTicks [1] -3 -2 -1 0 1 2 3 $yTicks [1] 0 50 100 150 200 attr(,&quot;class&quot;) [1] &quot;Augmented&quot; &quot;histogram&quot; &gt; VI(MyHist) This is a histogram, with the title: Histogram of x &quot;x&quot; is marked on the x-axis. Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, and 3 There are a total of 1000 elements for this variable. Tick marks for the y-axis are at: 0, 50, 100, 150, and 200 It has 14 bins with equal widths, starting at -3.5 and ending at 3.5 . The mids and counts for the bins are: mid = -3.25 count = 1 mid = -2.75 count = 8 mid = -2.25 count = 15 mid = -1.75 count = 41 mid = -1.25 count = 99 mid = -0.75 count = 154 mid = -0.25 count = 218 mid = 0.25 count = 173 mid = 0.75 count = 137 mid = 1.25 count = 99 mid = 1.75 count = 29 mid = 2.25 count = 21 mid = 2.75 count = 3 mid = 3.25 count = 2 When you first issued the library(BrailleR) command, there were several warnings printed out. One of them told you that the hist() function from the graphics package was masked by the BrailleR version. This means that when you use hist(), it is the BrailleR version being used. the BrailleR package includes hist() and boxplot() functions that pass the details of the command on to the graphics package functions of the same name, and then add any additional content required that will improve the ability to describe the visual graphic produced in text. In most cases, the graph producing functions pass on arguments such as main, xlab, or ylab (for main title and axis labels) to the relevant plotting commands without storing these elements in the object that is created. These elements are stored as graphical parameters and can be recalled using par() commands. 5.4 Scatter plots The description of the hist() function given above shows what is possible if a graph is created using a specific function. Many types of graphs are created using the plot() function which is actually a family of functions tailored to the type of object pushed into them. In addition, the plot() command is used to generate a simple scatter plot. This is slightly unfortunate in a theoretical sense, but useful in a practical sense. The use of plot() to generate a scatter plot cannot lead to a graph that the VI() functionality can work with. Unlike the hist() command which can be replaced by a function of the same name in the BrailleR package, the solution needs to be a new function of a new name. In addition to the new ScatterPlot() function, the BrailleR package has a FittedLinePlot() function that adds a fitted line to the scatter plot. The example given on the help page for ScatterPlot() proves that the plots generated by ScatterPlot() and FittedLinePlot() are identical to those that would normally be created using plot() and the addition of the fitted line using abline(). Running the command, example(ScatterPlot) command will give you the following: &gt; attach(airquality) &gt; op = par(mfcol = c(3, 2)) &gt; plot(Wind, Ozone, pch = 4) &gt; test1 = ScatterPlot(Wind, Ozone, pch = 4) &gt; test1 &gt; plot(Wind, Ozone) &gt; abline(coef(lm(Ozone ~ Wind)), col = 4) &gt; test2 = FittedLinePlot(Wind, Ozone, line.col = 4) &gt; test2 Figure 5.2: The six graphs generated by the example(ScatterPlot) &gt; par(op) &gt; detach(airquality) &gt; rm(test1) &gt; rm(test2) &gt; rm(op) 5.4.1 What’s in the scatter plot? Well first we might ask what is in the graph window to be confident that a plot was actually made. The WTF() command was put in BrailleR to address this problem. For the record, WTF is the acronym for “What’s this figure?” We’ll see it’s use in the next figure. It should tell us what appears in the graph window for things like axis lables and titles. The current solution offered by the BrailleR package for helping describe the points plotted in a scatter plot, is to attempt to replicate the summarisation done by sight using a text construct. A sighted person looking at a scatter plot might look at the trend being displayed by a set of points, but they might as easily partition the plot area into a grid pattern and recognize the density of points in each region. For example, attach(airquality) plot(Wind, Ozone, pch = 4) abline(v=min(Wind)+c(0.25,0.5,0.75)*(max(Wind)-min(Wind)), col=6) abline(h = min(Ozone, na.rm=TRUE) +c(0.25,0.5,0.75)*(max(Ozone, na.rm=TRUE)-min(Ozone, na.rm=TRUE)), col=6) WTF() Figure 5.3: Scatter plot of Ozone versus Wind with grid lines added. This graph has no main title; and o subtitle; &quot;Wind&quot; as the x axis label; &quot;Ozone&quot; as the y axis label; There are 116 points marked on this graph. detach(airquality) Counting the number of points falling into each cell of the graphic and presenting the results as a table would give the reader an impression of the density of those points. The grid lines added in this last figure were spaced uniformly, and chosen to split the region into a \\(4\\times4\\) grid of sixteen cells. Refining the number of cells and the distributional assumptions for the grid lines should make it easier to understand the relationship between the two variables being plotted. Note that the general picture is what is sought, not the specific locations of every point. The number of points for the last scatter plot are counted by the WhereXY() command as follows: attach(airquality) WhereXY(Wind, Ozone, grid = c(4,4)) 1 2 3 4 Sum 4 2 0 0 0 2 3 7 5 0 0 12 2 9 15 6 0 30 1 1 39 27 5 72 Sum 19 59 33 5 116 detach(airquality) In situations where the user is confident that the marginal distributions of either or both of the variables being plotted are normal, the grid lines should be spaced accordingly. 5.5 BrailleR commands used in this chapter The BrailleR versions of the hist() and boxplot() commands replace those found in the graphics package. The BrailleR commands ScatterPlot() and FittedLinePlot() are specific to BrailleR and replace the functionality usually obtained through use of plot() and abline(). The WTF() command helped prove a graph has appeared in the graph window, and WhereXY() has helped count the number of points falling into subregions of the plotting area. References "],
["WorkingBlind.html", "Chapter 6 Ways of Working in R as a Blind User 6.1 A little background 6.2 Using plain text files 6.3 Use of R markdown 6.4 Running jobs offline", " Chapter 6 Ways of Working in R as a Blind User This chapter presents some strategies to offer blind users options for producing and saving work from an R session. They complement the workflows used by sighted people, or replace the tools used by sighted people that are not able to be used by a blind person. 6.1 A little background A major issue for blind users of any mathematical or statistical software is how the work that has been done will be transferred into a form that can be included in reports or assignments. Standard methods of working with R are possible as a blind user, but there is one crucial task that sighted users find very easy that is beyond the reach of the blind user. A sighted user can highlight a section of the output window (including commands and results) and copy the text into a document using the mouse. This task is done easily in word processing or text documents using keyboard commands by the blind user, but is often impractical or impossible within many software applications. A solution has been provided within the BrailleR package by adapting a tool developed by another R user for a completely different purpose. The TeachingDemos package (Snow 2016), provided this tool. The original purpose was to quickly retain the output from an R session for distribution to students, and later in its development, to create output files (in MS Word or HTML) that would log the progress through an assignment question or project. 6.2 Using plain text files The code for saving the basic text output and commands being generated during an interactive session into a plain text file was among the early developments of the BrailleR package. The functions txtStart(), txtStop(), txtComment(), and txtSkip() were copied (with permission) from the TeachingDemos package; in addition, a txtOut() function that simplifies use of txtStart() was added to the BrailleR package. 6.3 Use of R markdown The general uptake of reproducible research ideas by many in the R community has vastly improved the opportunities for novice R users to create well-formatted HTML documents from markdown documents. This change in the general mindset has huge benefits for a blind user. An R markdown file is just plain text and is therefore accessible. Even more impressive, is that the HTML documents that result from these files are also very accessible to a blind reader. 6.4 Running jobs offline Blind users will benefit from switching to batch processing commands using R CMD BATCH at the command line, using the reproducible research functionality offered by the knitr package, or both strategies. Functions to help users (working under Windows operating systems) move to these ways of working have been included in the BrailleR package. In particular, a Windows user can use the MakeBatch() function to create a batch file in the current working directory, which creates the single command line that would be called to process a specified R script or R markdown file appropriately. The BrailleR package also shows a user how a test file would be processed using these batch files. Conversion of an R script or the history of the current workspace to an R markdown file are implemented using the R2Rmd() and History2Rmd() functions respectively. This suite of functions should assist the blind user migrate to the more efficient methods of working and ultimately become more proficient and efficient than their peers who are not yet making use of the reproducible research type of workflow. References "],
["RMarkdown.html", "Chapter 7 Use of R markdown to generate an analysis efficiently 7.1 General information 7.2 Replacing the Graphic User Interface (GUI) 7.3 Description of a single numeric variable 7.4 Analysis of a single continuous variable with respect to a single grouping factor 7.5 Use of BrailleR for linear regression 7.6 Analysis of a single continuous variable with respect to another continuous variable 7.7 BrailleR commands used in this chapter", " Chapter 7 Use of R markdown to generate an analysis efficiently In a general sense, R markdown has been used to create reports and package vignettes because it creates an analysis that is reproducible. The BrailleR package started to use R markdown in late 2014 as a method for generating simple analyses that might be needed by students taking introductory statistics courses. Since that time, the prevalence of R markdown as a teaching tool in these courses has increased. The functions described below are therefore also generating example R markdown files to help learn how to use R markdown. You will need the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the command library(BrailleR) now. 7.1 General information Each command described in this chapter and other similar commands draft a new R markdown file and then compile it to an HTML file that is easily read by a screen reader user. This HTML file is opened automatically if R is being used interactively, giving the blind user immediate access to the information. The content is presented using sufficiently marked up HTML code including headings and tables so that the blind user can make best use of their screen reading software. All graphs are given an “alt tag” when they are included in the HTML file, and can be presented using a text description available from the VI() functionality of the BrailleR package. In addition, the blind user may need one or more of the graphs in a variety of formats (png, pdf, eps, or svg), nicely formatted tables for insertion into documents (LaTeX or HTML), and access to the code that generated these graphs and tables (an R script). This is handled using add-on packages wherever possible so that blind users are completing tasks using the same tools as their sighted peers. For example, nicely tabulated results can be saved as individual text files for later inclusion in LaTeX documents uisng the xtable package (Dahl 2016). The commands shown in this chapter make use of R markdown, but they are not actually ready for direct use within other R markdown documents. If you wish to get the output you observe within the HTML documents that will be generated, you will need to extract the relevant parts of the R markdown script files that the commands create. That sounds harder than it is! 7.2 Replacing the Graphic User Interface (GUI) One major criticism of R often heard from novice users is that a graphic user interface (GUI) is much easier to use than the command line mode of operation. Blind users are no different in this respect, but as has been reported previously (Godfrey 2013b), none of the GUI-based front ends for R are accessible to the blind user. When considering the benefits of using a GUI mode of operation, we turn to the justification used for the creation of some of these interfaces; redacting all references to the GUI helps emphasize the reasons for their existence: R Commander aims “to support … the statistical functionality required for a basic-statistics course; to make it relatively difficult to do unreasonable things; and to render visible the relationship between choices made … and the R commands that they generate.” (Fox 2005). “Because R analyses must be called as text commands, the user is required to find out the name of the function that will accomplish their task, and then remember that name along with the names of the variables to feed it, and its argument options. Perhaps more fundamentally, many users have never dealt with a program that requires them to type in commands that manipulate objects in the program. For beginners, Deducer is designed to be an intuitive dialog based interface to common data manipulation and analysis tasks.” (Fellows 2012) “The scope of RKWard is deliberately broad, targeting both R novices and experts. For the first group, the aim is to allow any person with knowledge on statistical procedures to start using RKWard for their everyday work without having to learn anything about the R programming language, at least initially. At the same time, RKWard tries to support users who want to learn and exploit the full flexibility of the R language for automating or customizing an analysis.” (Rödiger et al. 2012) RKWard “avoids wrapping complex sequences of data manipulation or analysis into custom highlevel R functions. The task of providing high-level functions is logically independent of the development of the GUI frontend, and should best be addressed in dedicated R packages, where necessary.” (Rödiger et al. 2012) Making any of these GUI tools accessible is difficult because they were not developed using interface development toolkits that automatically build accessibility into the interface. Creation of a GUI such as R Commander is not a small undertaking. Retrospectively building in the necessary accessibility features would be a massive undertaking that the blind community could not reasonably expect of a very small development team. Duplicating the work done to create such a GUI tool from scratch using a development toolkit that helps build in the necessary elements for accessibility and then maintaining it as operating systems develop over time is not a practical solution either. It may be possible to improve the toolkits that are used to create the GUI options like R Commander or Deducer so that their development is not hindered while their accessibility becomes automatic; unfortunately, this requires knowledge well beyond my skill set. If blind users cannot make use of any of the GUI tools and we don’t have the necessary skills to develop such a tool that does work for ourselves, what solutions exist for us? When I’ve discussed the merits of various statistical software with other blind users, they have questioned the use of R by saying something like, “When I use software x, I can do y and z. How do I do that in R?” With respect to SAS for example, a user can build up a set of templates for various commonly used analyses for themselves. The same is true as an R user, but SAS users can get the templates by using the menus in the standard GUI, and they can keep the procedures in files for later use. SPSS users can do this as well. (These seem to be the most commonly used software options for blind users who communicate with me.) In either case, the code can be reused after issuing a few find/replace searches. It seems that even though it is more efficient to make use of this ability to re-use code templates, that many of the blind users of these software options prefer to use key presses to simulate mouse clicks in order to use the menus and dialogue boxes. When questioning them on their motives, we quickly come to the point that the use of menus and dialogue boxes offers a degree of comfort that tasks have been done correctly. The next crucial aspect worth mentioning is that the GUI provides the user with more output than can be obtained from typing out numerous commands in R. Searching for the right functions and then ensuring the syntax of their arguments is correct limits a blind user’s ability in any command-line software, just as it does for sighted users. The solution for a replacement of the GUI is to create convenience functions with simple names that require entry of a minimal number of arguments so that the user gets the maximum amount of useful information. This information might prove more than is needed for many users, but hopes to deliver what is needed by the widest possible range of blind users. Like RKWard, BrailleR functions generate R scripts that are somewhat verbose (Rödiger et al. 2012). 7.3 Description of a single numeric variable There are many commands needed to get the numeric and graphic summary measures that might be required to collect all relevant information on a single numeric variable. The UniDesc() command has been written as a shortcut for a blind user who wishes to obtain: the counts of points in the sample that were observed and not observed, the mean and trimmed mean, the five number summary: minimum, lower quartile, median, upper quartile, and maximum, the interquartile range (IQR) and standard deviation, measures of skewness and kurtosis, relying on the moments package (Komsta and Novomestky 2015), a histogram and/or a boxplot, a normality (quantile-quantile) plot, various tests for normality, courtesy of the nortest package (Gross and Ligges 2015) , and tests on the significance of the skewness and kurtosis, also courtesy of the moments package (Komsta and Novomestky 2015). The UniDesc() function can deliver all of this with minimal effort from the user. An example of the main output document (HTML) can be viewed by re-issuing the commands generated by calling example(UniDesc) while running R interactively. This issues the following commands. Ozone=airquality$Ozone UniDesc(Ozone, View=FALSE) rm(Ozone) # N.B. Various files and a folder were created in the working directory. # Please investigate them to see how this function worked. As an alternative, and if you do have a current internet connection you can view the result of running the UniDesc() command on the Ozone data in your browser without having to re-enter the example commands. You can also view the R markdown script created by Unidesc(Ozone) which starts witht he following lines: # Univariate analysis for Ozone #### Prepared by Jonathan Godfrey ```{r setup, purl=FALSE, include=FALSE} library(BrailleR) opts_chunk$set(dev=c(&quot;png&quot;, &quot;pdf&quot;, &quot;postscript&quot;, &quot;svg&quot;)) opts_chunk$set(comment=&quot;&quot;, echo=FALSE, fig.path=&quot;Ozone/Ozone-&quot;, fig.width=7) ``` ## Basic summary measures ```{r BasicSummaries} Ozone.count = length(Ozone) Ozone.unique = length(unique(Ozone)) Ozone.Nobs = sum(!is.na(Ozone)) Ozone.Nmiss = sum(is.na(Ozone)) Ozone.mean = mean(Ozone, na.rm = TRUE) Ozone.tmean5 = mean(Ozone, trim =0.025, na.rm = TRUE) Ozone.tmean10 = mean(Ozone, trim =0.05, na.rm = TRUE) Ozone.IQR = IQR(Ozone, na.rm = TRUE) Ozone.sd = sd(Ozone, na.rm = TRUE) Ozone.var = var(Ozone, na.rm = TRUE) Ozone.skew = moments::skewness(Ozone, na.rm = TRUE) Ozone.kurt = moments::kurtosis(Ozone, na.rm = TRUE) ``` ### Counts `r Ozone.count` values in all, made up of `r Ozone.unique` unique values, `r Ozone.Nobs` observed, and `r Ozone.Nmiss` missing values. ### Measures of location Data | all | 5% trimmed | 10% trimmed ----- | ------ | ----- | ------ Mean | `r Ozone.mean` | `r Ozone.tmean5` | `r Ozone.tmean10` ### Quantiles ```{r Quantiles1} Quantiles=quantile(Ozone, na.rm=TRUE) QList=c(&quot;Minimum&quot;, &quot;Lower Quartile&quot;, &quot;Median&quot;, &quot;Upper Quartile&quot;, &quot;Maximum&quot;) Results=data.frame(Quantile=QList, Value=Quantiles[1:5]) ``` ```{r QuantilesPrint, eval=FALSE} Results ``` ```{r QuantilesKable, results=&quot;asis&quot;, purl=FALSE} kable(Results, digits=4) ``` ### Measures of spread Measure | IQR | Standard deviation | Variance -------- | ------ | -------- | ------ Value | `r Ozone.IQR` | `r Ozone.sd` | `r Ozone.var` ## Basic univariate graphs ### Histogram ```{r Hist, fig.cap=&quot;The histogram&quot;, fig.height=5} VI(hist(Ozone, xlab=&quot;Ozone&quot;, main=&quot;Histogram of Ozone&quot;)) ``` ### Boxplot ```{r Boxplot, fig.cap=&quot;The boxplot&quot;, fig.height=3.5} VI(boxplot(Ozone, horizontal=TRUE, main = &quot;Boxplot of Ozone&quot;)) ``` ## Assessing normality ### Formal tests for normality ```{r NormalityTests} library(nortest) Results = matrix(0, nrow=6, ncol=2) dimnames(Results) = list(c(&quot;Shapiro-Wilk&quot;, &quot;Anderson-Darling&quot;, &quot;Cramer-von Mises&quot;, &quot;Lilliefors (Kolmogorov-Smirnov)&quot;, &quot;Pearson chi-square&quot;, &quot;Shapiro-Francia&quot;), c(&quot;Statistic&quot;, &quot;P Value&quot;)) SW =shapiro.test(Ozone) Results[1,] = c(SW$statistic, SW$p.value) AD = ad.test(Ozone) Results[2,] = c(AD$statistic, AD$p.value) CV = cvm.test(Ozone) Results[3,] = c(CV$statistic, CV$p.value) LI = lillie.test(Ozone) Results[4,] = c(LI$statistic, LI$p.value) PE = pearson.test(Ozone) Results[5,] = c(PE$statistic, PE$p.value) SF = sf.test(Ozone) Results[6,] = c(SF$statistic, SF$p.value) ``` ```{r NormalityTestsPrint, eval=FALSE} Results ``` ```{r NormalityTestsKable, results=&quot;asis&quot;, purl=FALSE} kable(Results, digits=c(4,4)) ``` ```{r NormalityTestsTex, purl=FALSE} library(xtable) ThisTexFile = &quot;Ozone/Ozone-Normality.tex&quot; TabCapt= &quot;Tests for normality: Variable is Ozone.&quot; print(xtable(Results, caption=TabCapt, label=&quot;OzoneNormality&quot;, digits=4, align=&quot;lrr&quot;), file=ThisTexFile) ``` ### Normality plot ```{r NormPlot, fig.cap=&quot;The normality plot&quot;, fig.height=7} qqnorm(Ozone, main = &quot;Normality Plot for Ozone&quot;) qqline(Ozone) ``` ## Formal tests of moments ```{r MomentsTests} library(moments) Results = matrix(0, nrow=2, ncol=3) dimnames(Results)= list(c( &quot;D&#39;Agostino skewness&quot;, &quot;Anscombe-Glynn kurtosis&quot;), c(&quot;Statistic&quot;,&quot;Z&quot;, &quot;P Value&quot;)) AG = moments::agostino.test(Ozone) AN = moments::anscombe.test(Ozone) Results[1,] = c(AG$statistic, AG$p.value) Results[2,] = c(AN$statistic, AN$p.value) ``` ```{r MomentsTestsPrint, eval=FALSE} Results ``` ```{r MomentsTests2, results=&quot;asis&quot;, purl=FALSE} kable(Results, digits=c(4,3,4)) ``` ```{r MomentsTestsTex, purl=FALSE} library(xtable) ThisTexFile = &quot;Ozone/Ozone-Moments.tex&quot; TabCapt= &quot;Tests on moments: Variable isOzone&quot; print(xtable(Results, caption=TabCapt, label=&quot;OzoneMoments&quot;, digits=4, align=&quot;lrrr&quot;), file=ThisTexFile) ``` The document header includes a code chunk that sets the options for the knit2html() process used to convert this file to HTML. This processing allows for: multiple file types for the graphs, ensures a minimum of extra text in the output, hides the R code from the HTML file, sets the location of the saved graphs, and establishes the height of the figures. The user that does not like these settings can edit the markdown file for themselves and re-process the file, but the intention is to deliver more than all users would want so that as many users as possible get what they need. This R markdown script uses the VI() method for the graphs as well as the code that generates the HTML (via markdown) and LaTeX tables (using the xtable package). Take note of the arguments supplied to the code chunks for the graphs; these include a fig.cap which is used as an Alt tag in the resulting HTML files. The quoted string is the only text that is read aloud by a blind person’s screen reading software as they move the cursor onto the graph while reading through the HTML document. The methods used for creating tables in markdown (either directly or using the kable() command from the knitr package) both lead to a formatted HTML table that is easily navigated by a screen reader using keystrokes that help move between rows or columns. The result is that the HTML document is about as user-friendly as can be expected for a blind user. It is important to recognize that some of the text is arranged for the optimal use by a blind person; it is possible to alter the cosmetics of the HTML document without altering the experience for blind users. Given a blind user might be accompanied by sighted classmates, teaching staff, or colleagues, making the HTML pages presentable is desirable; this has been achieved using a custom style sheet (CSS) included in the package. This style includes some color, adequate spacing of content and other features that improve the clarity of the presented material which is important for a user with some residual vision that wishes to read through the results visually rather than using screen reading software. If all of the optional arguments of the UniDesc() function are set at their defaults, the HTML file is automatically opened in a browser (courtesy of the View argument); it puts the R markdown file, the R script, and the HTML document in the current working directory, while the LaTeX and graph files are all placed in a subdirectory. Several other convenience functions have been created that follow the same process as the UniDesc() function. The OneFactor() function compares one continuous response variable to a categorical variable, while TwoFactors() allows for two categorical variables and their possible interaction to help explain a single continuous response variable. These functions create group summary statistics and suitable graphs that a sighted audience might expect to see. Comparing a continuous response variable to a continuous predictor variable is achieved using the OnePredictor() function. Each of these functions has an example using data from the datasets package so a user can see what can be expected from these functions. 7.4 Analysis of a single continuous variable with respect to a single grouping factor There are many commands needed to get the numeric and graphic summary measures that might be required to collect all relevant information on a single numeric variable when it might depend on a grouping factor. The OneFactor() command has been written as a shortcut for a blind user who wishes to obtain: the counts of observations within each group, the mean, standard deviation and standard error for each group, comparative boxplots and/or dotplots, the one-way analysis of variance, and Tukey’s Honestly Significant Difference (HSD) test on the significance of the between group differences. An example of the main output document (HTML) can be viewed by re-issuing the commands generated by calling example(OneFactor) while running R interactively. This issues the following commands. data(airquality) # the following line returns an error: ## OneFactor(&quot;Ozone&quot;, &quot;Month&quot;, airquality, View=FALSE) # so we make a copy of the data.frame, and fix that: airquality2 = airquality airquality2$Month = as.factor(airquality$Month) # and now all is good to try: OneFactor(&quot;Ozone&quot;, &quot;Month&quot;, airquality2) # N.B. Various files and a folder were created in the working directory. # Please investigate them to see how this function worked. As an alternative, and if you do have a current internet connection you can view the result of running the OneFactor() command on the Ozone data in your browser without having to re-enter the example commands. The example here demonstrates the point that the grouping variable must be a factor. The month variable is not stored as a factor in the airquality data so its use would have created an error. 7.5 Use of BrailleR for linear regression Linear regression is almost always taught using graphical techniques, especially for the validation of the model being fitted. Of particular note is the way an instructor would teach sighted students about the sensibility of fitting any line to some data which cannot be easily judged even using the WhereXY() function described earlier. A blind student lacking an embosser to produce a tactile image that shows the fitted line and the data, will almost certainly need to fit the model and see how good or bad it is. These blind students are therefore even more reliant on the residual analysis than their sighted classmates The VI() command can be applied to a linear model object. The specific function to do this is found in the VI.lm() function, but most users do not need to explicitly use VI.lm() because the call to VI() will know to use the VI.lm() function if it is the right one to use at the time. The VI.lm() function generates so much text as a substitute for the graphs used by sighted users, that it is easier to put this text in an HTML document and have that new document opened in a browser instead of trying to use a screen reader within the R session. Let’s see an example using the airquality data. Please note: The example is chosen for reproducibility and its lack of statistical validity, as this is the best way to demonstrate the function’s value to a blind user. A simple linear regression model might be created and investigated using: data(airquality) MyModel = lm(Ozone~Wind, data=airquality) summary(MyModel) Call: lm(formula = Ozone ~ Wind, data = airquality) Residuals: Min 1Q Median 3Q Max -51.572 -18.854 -4.868 15.234 90.000 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 96.8729 7.2387 13.38 &lt; 2e-16 *** Wind -5.5509 0.6904 -8.04 9.27e-13 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 26.47 on 114 degrees of freedom (37 observations deleted due to missingness) Multiple R-squared: 0.3619, Adjusted R-squared: 0.3563 F-statistic: 64.64 on 1 and 114 DF, p-value: 9.272e-13 par(mfrow=c(2,2)) plot(MyModel) (#fig:AirQuality.lm)Diagnostic plots for the simple linear regression model. The user now has a model stored as MyModel in the current workspace, has printed a summary of that model, and has plotted a set of four diagnostic plots in a \\(2\\times{}2\\) grid. The blind user will still need to issue those commands so that the output is created to meet the expectations of the sighted audience, but will also find value in issuing the two extra commands VI(MyModel) VI(summary(MyModel)) The use of the second of these commands will generate The term which is significant to 1% is Wind with an estimate of -5.550923 and P-Value of 9.271974e-13 which will be a much easier reading exercise for a screen reader user than would be the standard summary() output given earlier. Note that not all the information contained in the standard summary is contained in this output. The output from use of the VI() command on the linear model can be viewed in your browser if you have a current internet connection. If you do not have a connection at this time, you will need to re-issue some of the above commands for yourself in an R session. The HTML document created by VI.lm() is based on the results of the UniDesc() function applied to the Pearson residuals for the model and a number of other graphs and tables used to validate the model. The included graphs are of the residuals plotted against the fitted values, the order the data were collected (assumes data are presented in this order), the leverages, and the preceding residual. Each of these graphs is subjected to scrutiny using the WhereXY() function as described earlier. The marginal distribution of the residuals is assumed normal while the fitted values and leverages are categorized on the basis of a uniform distribution. The assumption of normality for residuals is immediately obvious, but the choice to explicitly use an incorrect assumption of uniformity for the other values needs to be justified. While these quantities aare unlikely to be uniformly distributed, the intended audience needs to know about the pattern of their presentation on the graph; this should be easier to understand if the categorization is done using uniform spacing rather than another distribution that is unfamiliar to the intended audience. A table of unusual observations is created that uses rules of thumb for magnitude of residuals, leverages, and Cook’s distances. This table is presented in the HTML document and converted to a LaTeX file using the xtable package. The raw LaTeX for this table looks like: % latex table generated in R 3.5.1 by xtable 1.8-2 package % Mon Aug 13 14:24:06 2018 \\begin{table}[ht] \\centering \\begin{tabular}{rrrrrrr} \\hline &amp; Ozone &amp; Wind &amp; Fit &amp; St.residual &amp; Leverage &amp; Cooks.distance \\\\ \\hline 9 &amp; 8 &amp; 20.1000 &amp; -14.7007 &amp; 0.8934 &amp; 0.0799 &amp; 0.0347 \\\\ 18 &amp; 6 &amp; 18.4000 &amp; -5.2641 &amp; 0.4370 &amp; 0.0582 &amp; 0.0059 \\\\ 22 &amp; 11 &amp; 16.6000 &amp; 4.7276 &amp; 0.2408 &amp; 0.0395 &amp; 0.0012 \\\\ 48 &amp; 37 &amp; 20.7000 &amp; -18.0312 &amp; 2.2149 &amp; 0.0885 &amp; 0.2304 \\\\ 62 &amp; 135 &amp; 4.1000 &amp; 74.1141 &amp; 2.3847 &amp; 0.0312 &amp; 0.0880 \\\\ 86 &amp; 108 &amp; 8.0000 &amp; 52.4655 &amp; 2.1428 &amp; 0.0110 &amp; 0.0247 \\\\ 101 &amp; 110 &amp; 8.0000 &amp; 52.4655 &amp; 2.2233 &amp; 0.0110 &amp; 0.0265 \\\\ 117 &amp; 168 &amp; 3.4000 &amp; 77.9998 &amp; 3.6474 &amp; 0.0370 &amp; 0.2309 \\\\ 121 &amp; 118 &amp; 2.3000 &amp; 84.1058 &amp; 1.3164 &amp; 0.0475 &amp; 0.0430 \\\\ 126 &amp; 73 &amp; 2.8000 &amp; 81.3303 &amp; -0.3204 &amp; 0.0426 &amp; 0.0023 \\\\ 148 &amp; 14 &amp; 16.6000 &amp; 4.7276 &amp; 0.3561 &amp; 0.0395 &amp; 0.0026 \\\\ \\hline \\end{tabular} \\caption{Listing of suspected outliers and influential observations.} \\label{InflObsMyModel} \\end{table} Note that the automatic formatting of this table as performed by the xtable package has not been altered to meet a specified publication style. Ultimatly, users will need to alter the presentation to meet publisher specifications for themselves. 7.6 Analysis of a single continuous variable with respect to another continuous variable The OnePredictor() command is similar to the OneFactor() command describe earlier in this chapter and makes use of the VI() command as applied to the simple linear regression model fitted to a pair of continuous variables, one of which is determined to respond to the other. The OnePredictor() command has been written as a shortcut for a blind user who wishes to obtain: the counts of observations within each group, An example of the main output document (HTML) can be viewed by re-issuing the commands generated by calling example(OnePredictor) while running R interactively. This issues the following commands. data(airquality) OnePredictor(&quot;Ozone&quot;, &quot;Wind&quot;, airquality) # N.B. Various files and a folder were created in the working directory. # Please investigate them to see how this function worked. As an alternative, and if you do have a current internet connection you can view the result of running the OnePredictor() command on the Ozone data in your browser without having to re-enter the example commands. 7.7 BrailleR commands used in this chapter The first two BrailleR commands introduced in this chapter were the UniDesc() and OneFactor() commands; they used the VI() command in the R markdown files that they create, as was described back in Chapter 4, to give the text descriptions for graphs. We then saw a new use of the VI() command and several other commands designed to generate common analyses quickly. These included the OnePredictor(), etc. References "],
["Personalising.html", "Chapter 8 Personalising BrailleR 8.1 General 8.2 Settings that are about you 8.3 Settings for saving 8.4 BrailleR commands used in this chapter", " Chapter 8 Personalising BrailleR 8.1 General Once you’ve played with a few examples, you might want to settle on the way you want BrailleR to work for you. There are a wide range of options needed to get the best out of the BrailleR package specific to each user, and perhaps for each user who wants specific settings to be in play for different projects. All BrailleR settings are stored in a local file, and also in a global file. These files are both called BrailleROptions. The global settings file is located in a folder called MyBrailleR which is located where you let BrailleR choose when you first loaded the package using the library(BrailleR) command. You could have let this be a temporary location so you will be asked every time you start BrailleR until you let the standard location be used. The BrailleROptions file in the MyBrailleR folder will be used unless a local version is found. This local file will be in the working directory being used when the package is loaded. 8.2 Settings that are about you 8.2.1 Who is the R markdown file being written by? You might want your analyses to use your name instead of the default name BrailleR. Do this using the SetAuthor() function. e.g. SetAuthor(&quot;Jonathan Godfrey&quot;) OK, you ought to use your name not mine, but you get the point. This will have an instant impact, even on the examples for BrailleR functions. Set the author and then try example(UniDesc) for example. 8.2.2 The use of the VI() command The BrailleR package was intended for use by blind people, but we need to see more in text than do most people in our intended audiences. You may wish to turn off or on the use of the output generated by the VI() commands throughout the R markdown files written by such commands as UniDesc() etc. Do this using the functions GoBlind() to use the VI() command, and GoSighted() to turn it off. I think a standard workflow might be to start BrailleR, do some analyses using UniDesc() or OnePredictor() and the like, and then having worked out what was working well, use GoSighted() and re-issue the commands that you want to share with others. Don’t forget to GoBlind() again though so that you can get the text descriptions back when you need them. 8.3 Settings for saving 8.4 BrailleR commands used in this chapter SetAuthor(), GoBlind() and GoSighted(), "],
["GGPlot.html", "Chapter 9 The ggplot world and BrailleR 9.1 Plotting a continuous variable against a categorical variable 9.2 Time series plots 9.3 Path plots 9.4 Facets is the ggplot term for trellis’ panels 9.5 Rescaling of the axes", " Chapter 9 The ggplot world and BrailleR The use of the ggplot style of graph production has increased markedly since its inception. The grammar of graphics as seen in the R code used to create the extremely wide range of graphs is seldom human-interpretable with ease. Creation of suitable support functionality via the VI() command is very definitely required. An initial attempt to extract any useful infromation from these graphs was contributed to the BrailleR package by Tony Hirst. Significant improvement has been made by Debra Warren as part of her postgraduate work under the supervision of Paul Murrell at the University of Auckland. Much of what is displayed in this chapter is only worth offering because of Debra’s work and the interactions had between her, Paul and I in the second half of 2017. N.B. the commands here are exact copies of the commands presented in Wickham (2009) or some minor alterations to them; any changes will be explicitly noted. All plots are created using the figure numbers from Wickham (2009) or the page numbers if no figure number was given. They are then investigated using the VI() command from the BrailleR package. You will need some additional packages to the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the commands: library(BrailleR) library(ggplot2) Attaching package: &#39;ggplot2&#39; The following objects are masked from &#39;package:BrailleR&#39;: xlab, ylab library(magrittr) Note that one data set used for these examples is created by Wickham (2009) while the others are included in the ggplot2 package. set.seed(1410) dsmall &lt;- diamonds[sample(nrow(diamonds), 100),] One important note for the graphs in this chapter is the difference in the way they appear here, as compared to the original figures of Wickham (2009) where differing height and width parameters have been set for each graph. For example, in the following graph, the points are smaller than in the original figure, and the aspect ratio is slightly different. The consequence is that this graph looks less cluttered than does the original. p11a = qplot(carat, price, data = diamonds) p11a Figure 9.1: First graph on page 11 of Wickham (2009) VI(p11a) This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. The chart is a set of 53940 points. Note that unlike some other ways the VI() command has worked, the graph was not created by the nesting of the call to render the graph when nested inside the VI() command. In all the examples that follow, I use the pipe %&gt;% operator from the magrittr package to push the graph into the VI() function. fig2.2a = qplot(carat, price, data = dsmall, colour = color) fig2.2a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.5, 1.0, 1.5, 2.0 and 2.5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. There is a legend indicating that colour is used to represent color, with 7 levels: D represented by colour very deep purple, E represented by colour vivid purplish blue, F represented by colour moderate blue, G represented by colour vivid bluish green, H represented by colour brilliant green, I represented by colour vivid yellow green and J represented by colour vivid greenish yellow. The chart is a set of 100 points. fig2.2a Figure 9.2: Left pane of Figure 2.2 of Wickham (2009) We haven’t been able to tell what exact colour was used in the Wickham (2009) rendering of this graph, but there has obviously been some minor alteration of the colour palette being used by the ggplot2 package. fig2.2b = qplot(carat, price, data = dsmall, shape = cut) fig2.2b %&gt;% VI() Warning: Using shapes for an ordinal variable is not advised This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.5, 1.0, 1.5, 2.0 and 2.5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. There is a legend indicating that shape is used to represent cut, with 5 levels: Fair represented by shape solid circle, Good represented by shape solid triangle, Very Good represented by shape solid square, Premium represented by shape plus and Ideal represented by shape boxed X. The chart is a set of 100 points. fig2.2b Warning: Using shapes for an ordinal variable is not advised Figure 9.3: Right pane of Figure 2.2 To get semi-transparent points: fig2.3b = qplot(carat, price, data = diamonds, alpha = I(1/100)) fig2.3b Figure 9.4: Middle pane from Figure 2.3 fig2.3b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. The chart is a set of 53940 points. The chart has alpha set to 0.01. To add a smoother (default is loess for n&lt;1000): fig2.4a = qplot(carat, price, data = dsmall, geom = c(&quot;point&quot;, &quot;smooth&quot;)) fig2.4a `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Figure 9.5: Left pane of Figure 2.4 fig2.4a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.5, 1.0, 1.5, 2.0 and 2.5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000, 15000 and 20000. It has 2 layers. Layer 1 is a set of 100 points. Layer 2 is a smoothed curve using method &#39;auto&#39; with confidence intervals. 9.1 Plotting a continuous variable against a categorical variable fig2.8a = qplot(color, price / carat, data = diamonds, geom = &quot;jitter&quot;) fig2.8a Figure 9.6: Left pane of Figure 2.8 fig2.8a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;price/carat&#39; with labels 5000, 10000 and 15000. The chart is a set of 53940 points. fig2.8b = qplot(color, price / carat, data = diamonds, geom = &quot;boxplot&quot;) fig2.8b fig2.8b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;price/carat&#39; with labels 5000, 10000 and 15000. The chart is a boxplot comprised of 7 boxes with whiskers. There is a box at x=D. It has median 3410.53. The box goes from 2455 to 4749.31, and the whiskers extend to 1128.12 and 8183.33. There are 338 outliers for this boxplot. There is a box at x=E. It has median 3253.66. The box goes from 2430.3 to 4508.41, and the whiskers extend to 1078.12 and 7616.39. There are 593 outliers for this boxplot. There is a box at x=F. It has median 3494.32. The box goes from 2587.1 to 4947.22, and the whiskers extend to 1168 and 8477.5. There are 585 outliers for this boxplot. There is a box at x=G. It has median 3490.38. The box goes from 2538.24 to 5500, and the whiskers extend to 1139.02 and 9937.2. There are 119 outliers for this boxplot. There is a box at x=H. It has median 3818.89. The box goes from 2396.88 to 5127.28, and the whiskers extend to 1051.16 and 9220. There are 13 outliers for this boxplot. There is a box at x=I. It has median 3779.74. The box goes from 2344.65 to 5196.75, and the whiskers extend to 1151.72 and 9397.5. There are 0 outliers for this boxplot. There is a box at x=J. It has median 3780. The box goes from 2562.87 to 4927.95, and the whiskers extend to 1080.65 and 8426.13. There are 3 outliers for this boxplot. When seeking to use shading or opaqueness to describe the density of the points, the fact the size of the points has an impact on the opaqueness is not currently realised by BrailleR. fig2.9b = qplot(color, price / carat, data = diamonds, geom = &quot;jitter&quot;, alpha = I(1 / 50)) fig2.9b Figure 9.7: Middle pane of Figure 2.9 fig2.9b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;price/carat&#39; with labels 5000, 10000 and 15000. The chart is a set of 53940 points. The chart has alpha set to 0.02. 9.1.1 Univariate plots fig2.10a = qplot(carat, data = diamonds, geom = &quot;histogram&quot;) fig2.10a `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 9.8: Left pane of Figure 2.10 fig2.10a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;&#39; with labels 0, 5000, 10000 and 15000. The chart is a bar chart containing 30 vertical bars. Warning: This figure does look different to the original in Wickham (2009) ins spite of using the same code and same data. fig2.10b = qplot(carat, data = diamonds, geom = &quot;density&quot;) fig2.10b Figure 9.9: Right pane of Figure 2.10 fig2.10b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;&#39; with labels 0.0, 0.5, 1.0 and 1.5. The chart is a type that VI isn&#39;t able to process. fig2.11c = qplot(carat, data = diamonds, geom = &quot;histogram&quot;, binwidth = 0.01, xlim = c(0,3)) fig2.11c Warning: Removed 32 rows containing non-finite values (stat_bin). Figure 9.10: Right pane of Figure 2.11 fig2.11c %&gt;% VI() Warning: Removed 32 rows containing non-finite values (stat_bin). This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2 and 3. It has y-axis &#39;&#39; with labels 0, 1000 and 2000. The chart is a bar chart containing 299 vertical bars. The data is separated by implication in the following graphs. The legend is automatically generated and has altered in appearance since the original was prodcued in Wickham (2009). fig2.12a = qplot(carat, data = diamonds, geom = &quot;density&quot;, colour = color) fig2.12a Figure 9.11: Left pane of Figure 2.12 fig2.12a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;&#39; with labels 0.0, 0.5, 1.0, 1.5 and 2.0. There is a legend indicating that colour is used to represent color, with 7 levels: D represented by colour very deep purple, E represented by colour vivid purplish blue, F represented by colour moderate blue, G represented by colour vivid bluish green, H represented by colour brilliant green, I represented by colour vivid yellow green and J represented by colour vivid greenish yellow. The chart is a type that VI isn&#39;t able to process. fig2.12b = qplot(carat, data = diamonds, geom = &quot;histogram&quot;, fill = color) fig2.12b `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 9.12: Right pane of Figure 2.12 fig2.12b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;&#39; with labels 0, 5000, 10000 and 15000. There is a legend indicating that fill is used to represent color, with 7 levels: D represented by fill very deep purple, E represented by fill vivid purplish blue, F represented by fill moderate blue, G represented by fill vivid bluish green, H represented by fill brilliant green, I represented by fill vivid yellow green and J represented by fill vivid greenish yellow. The chart is a bar chart containing 210 vertical bars. 9.1.2 Bar charts for categorical variables fig2.13a = qplot(color, data = diamonds, geom = &quot;bar&quot;) #geom=&quot;bar&quot; is the default fig2.13a Figure 9.13: Left pane of Figure 2.13 fig2.13a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;&#39; with labels 0, 3000, 6000 and 9000. The chart is a bar chart containing 7 vertical bars. Bar 1 is centered horizontally at D, and spans vertically from 0 to 6775. Bar 2 is centered horizontally at E, and spans vertically from 0 to 9797. Bar 3 is centered horizontally at F, and spans vertically from 0 to 9542. Bar 4 is centered horizontally at G, and spans vertically from 0 to 11292. Bar 5 is centered horizontally at H, and spans vertically from 0 to 8304. Bar 6 is centered horizontally at I, and spans vertically from 0 to 5422. Bar 7 is centered horizontally at J, and spans vertically from 0 to 2808. need to check… fig2.13b = qplot(color, data = diamonds, geom = &quot;bar&quot;, weight = carat) fig2.13b Figure 9.14: Right pane of Figure 2.13 fig2.13b = qplot(color, data = diamonds, geom = &quot;bar&quot;, weight = carat) + scale_y_continuous(&quot;carat&quot;) fig2.13b Figure 9.14: Right pane of Figure 2.13 fig2.13b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;&#39; with labels 0, 2500, 5000 and 7500. The chart is a bar chart containing 7 vertical bars. Bar 1 is centered horizontally at D, and spans vertically from 0 to 4456.56. Bar 2 is centered horizontally at E, and spans vertically from 0 to 6445.12. Bar 3 is centered horizontally at F, and spans vertically from 0 to 7028.05. Bar 4 is centered horizontally at G, and spans vertically from 0 to 8708.28. Bar 5 is centered horizontally at H, and spans vertically from 0 to 7571.58. Bar 6 is centered horizontally at I, and spans vertically from 0 to 5568. Bar 7 is centered horizontally at J, and spans vertically from 0 to 3263.28. 9.2 Time series plots It looks like the data used in the next graph has been updated since the publication of Wickham (2009) fig2.14a = qplot(date, unemploy / pop, data = economics, geom = &quot;line&quot;) fig2.14a Figure 9.15: Left pane of Figure 2.14 fig2.14a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;date&#39; with labels 1970, 1980, 1990, 2000 and 2010. It has y-axis &#39;unemploy/pop&#39; with labels 0.02, 0.03, 0.04 and 0.05. The chart is a set of 1 line. Line 1 connects 574 points. 9.3 Path plots year &lt;- function(x) as.POSIXlt(x)$year + 1900 fig2.15b = qplot(unemploy / pop, uempmed, data = economics, geom = &quot;path&quot;, colour=year(date)) #+ scale_area() # no longer works fig2.15b Figure 9.16: Right pane of Figure 2.15 fig2.15b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;unemploy/pop&#39; with labels 0.02, 0.03, 0.04 and 0.05. It has y-axis &#39;uempmed&#39; with labels 5, 10, 15, 20 and 25. There is a legend indicating that colour is used to represent year(date), ranging from 1967 represented by colour dark purplish blue to 2015 represented by colour brilliant blue. The chart is a type that VI isn&#39;t able to process. 9.4 Facets is the ggplot term for trellis’ panels The aspect ratio for the plot region is something that needs to be considered. I’ve manually adjusted the plotting window here so that the graph more closely matches that of Wickham (2009) but it is not an exact match. fig2.16a = qplot(carat, data = diamonds, facets = color ~ ., geom = &quot;histogram&quot;, binwidth = 0.1, xlim = c(0, 3)) fig2.16a Warning: Removed 32 rows containing non-finite values (stat_bin). Figure 9.17: Left side of Figure 2.16 fig2.16a %&gt;% VI() Warning: Removed 32 rows containing non-finite values (stat_bin). This is an untitled chart with no subtitle or caption. The chart is comprised of 7 panels containing sub-charts, arranged vertically. The panels represent different values of color. Each sub-chart has x-axis &#39;carat&#39; with labels 0, 1, 2 and 3. Each sub-chart has y-axis &#39;&#39; with labels 0, 500, 1000, 1500, 2000 and 2500. Panel 1 represents data for color = D. Panel 1 is a bar chart containing 29 vertical bars. Panel 2 represents data for color = E. Panel 2 is a bar chart containing 29 vertical bars. Panel 3 represents data for color = F. Panel 3 is a bar chart containing 29 vertical bars. Panel 4 represents data for color = G. Panel 4 is a bar chart containing 29 vertical bars. Panel 5 represents data for color = H. Panel 5 is a bar chart containing 29 vertical bars. Panel 6 represents data for color = I. Panel 6 is a bar chart containing 29 vertical bars. Panel 7 represents data for color = J. Panel 7 is a bar chart containing 29 vertical bars. fig2.16b = qplot(carat, ..density.., data = diamonds, facets = color ~ ., geom = &quot;histogram&quot;, binwidth = 0.1, xlim = c(0, 3)) fig2.16b Warning: Removed 32 rows containing non-finite values (stat_bin). Figure 9.18: Right side of Figure 2.16 fig2.16b %&gt;% VI() Warning: Removed 32 rows containing non-finite values (stat_bin). This is an untitled chart with no subtitle or caption. The chart is comprised of 7 panels containing sub-charts, arranged vertically. The panels represent different values of color. Each sub-chart has x-axis &#39;carat&#39; with labels 0, 1, 2 and 3. Each sub-chart has y-axis &#39;..density..&#39; with labels 0.0, 0.5, 1.0, 1.5 and 2.0. Panel 1 represents data for color = D. Panel 1 is a bar chart containing 29 vertical bars. Panel 2 represents data for color = E. Panel 2 is a bar chart containing 29 vertical bars. Panel 3 represents data for color = F. Panel 3 is a bar chart containing 29 vertical bars. Panel 4 represents data for color = G. Panel 4 is a bar chart containing 29 vertical bars. Panel 5 represents data for color = H. Panel 5 is a bar chart containing 29 vertical bars. Panel 6 represents data for color = I. Panel 6 is a bar chart containing 29 vertical bars. Panel 7 represents data for color = J. Panel 7 is a bar chart containing 29 vertical bars. 9.5 Rescaling of the axes p26a = qplot(carat, price, data = dsmall, log = &quot;xy&quot;) p26a Figure 9.19: First graph on page 26 of p26a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.3, 0.5 and 1.0. It has y-axis &#39;price&#39; with labels 300, 1000, 3000 and 10000. The chart is a set of 100 points. fig3.6 = qplot(displ, hwy, data=mpg, facets =~ year) + geom_smooth() fig3.6 `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Figure 9.20: Figure 3.6 of fig3.6 %&gt;% VI() This is an untitled chart with no subtitle or caption. The chart is comprised of 2 panels containing sub-charts, arranged horizontally. The panels represent different values of year. Each sub-chart has x-axis &#39;displ&#39; with labels 2, 3, 4, 5, 6 and 7. Each sub-chart has y-axis &#39;hwy&#39; with labels 20, 30 and 40. Each sub-chart has 2 layers. Panel 1 represents data for year = 1999. Layer 1 of panel 1 is a set of 117 points. Layer 2 of panel 1 is a smoothed curve using method &#39;auto&#39; with confidence intervals. Panel 2 represents data for year = 2008. Layer 1 of panel 2 is a set of 117 points. Layer 2 of panel 2 is a smoothed curve using method &#39;auto&#39; with confidence intervals. References "],
["WriteR.html", "Chapter 10 Getting started with the WriteR application 10.1 Getting the required software (Windows users only) 10.2 Other operating systems 10.3 Checking your system is ready 10.4 Opening WriteR from BrailleR 10.5 What can I do with WriteR? 10.6 Our first HTML file 10.7 BrailleR commands used in this chapter", " Chapter 10 Getting started with the WriteR application The WriteR application was written to support use of R markdown and the BrailleR package. It is a Python script making use of wxPython to help build the graphic user interface (GUI) in such a way that it works for screen reader users. This book has been written in R markdown, and the author has made extensive use of WriteR because it offers so many convenient tools for a blind user wanting to write R markdown files. The script is in the BrailleR package, but it cannot run unless the user has both Python and wxPython installed. Commands have been included in the BrailleR package to help Windows users obtain installation files for them. Users of other operating systems currently have to install Pandoc, Python and WxPython independently, but these tools may well already be installed. 10.1 Getting the required software (Windows users only) You can check if a version of Python is already installed on your computer using Sys.which(&quot;Python&quot;) ## Python ## &quot;C:\\\\Python27\\\\Python.exe&quot; The output above shows you that I have Python 2.7 installed on my computer, and that it can be found in the folder I know is the default location. You can use this command later to check your progress, but there are other ways to check that return more useful detail What it does not show you is whether the installation of Python is suited for a 64 bit machine, or is the more universal 32 bit installation. We must have an exact match between the version of Python 2.7 and the version of R being used. The files downloaded as a consequence of running commands in this set of instructions will be saved in your MyBrailleR folder. You will need to follow the instructions and answer questions that arise whenever you install new software, but you should probably read all the way through this set of instructions before getting underway. Ultimately, you will need a mainstream tool to process the markdown files you write into other formats. The WriteR application will end up using a tool called “pandoc” to do this so we need to get this installed. If you do not have an installation of Pandoc and Python (either 2.7 or 3) then you can use some functions from the BrailleR package to help make the setup smoother. Remember to load the package using: library(BrailleR) It doesn’t matter if you install Python before or after Pandoc. Let’s first install Pandoc using the command: GetPandoc() There are two sets of instructions from this point onwards; you will follow only one of them. These instructions fetch the installation files from the reputable Python sites. Windows and any security software you might have should know that, but you can never tell! You will may need to let Windows know it is OK to install the software in the default location. The pop-up might not appear as the window with focus so if things look like they’re going slowly, look around for the pop-up window. 10.1.1 I do not have Python 3 installed You do not need to install Python 2.7 if you already have Python 3; the WriteR application will work with either version of Python. I prefer to recommend that you install Python 2.7 here because it helps with a variety of other tools found in the BrailleR package. The following commands automatically download the installation files needed for Python 2.7, and start the installation process going. Issue them at the R prompt GetPython27() As the installer proceeds, there is one small matter to resolve. You need to make sure that as part of the installation, the Python folders are added to your system path. This makes it possible to run Python scripts from any folder on your computer and for R to see where to find Python. The next few commands will fail if this is not done properly. If you missed that step during the installation, look for the installer file in your MyBrailleR folder and run it again manually before proceeding. We can check the installation has worked properly at this point using: reticulate::py_config() ## python: C:\\Python27\\python.exe ## libpython: python27.dll ## pythonhome: C:\\Python27 ## version: 2.7.15 (v2.7.15:ca079a3ea3, Apr 30 2018, 16:30:26) [MSC v.1500 64 bit (AMD64)] ## Architecture: 64bit ## numpy: [NOT FOUND] ## ## python versions found: ## C:\\Python27\\python.exe ## C:\\Python27\\\\python.exe This is a much stronger set of tests than was done earlier. In particular, the reticulate package makes sure that the installation of Python and R are both using a 32 bit, or if appropriate for your computer, a 64 bit installation. Now get the additional Python modules needed for WriteR using: GetWxPython27() Once you have completed these installations, you are ready to go. You shouldn’t need to keep the installation files, but why not keep them just in case. You can now skip to the section which shows you how to check everything is ready for using WriteR. 10.1.2 I do have Python 3 installed If you have Python 3 on your system, it is still worth installing it again so that it gets updated to the most recent release. Use GetPython3() Instructions for getting the wx module for Python 3 installed need completion. Help from a Python 3 user is clearly needed, but the latest approach using a pip command should be promising. Once you have completed these installations, you are ready to go. You shouldn’t need to keep the installation files, but why not keep them just in case. 10.2 Other operating systems 10.3 Checking your system is ready All going to plan, you should now have Python on your system, and the additional wxPython modules as well. You only need to check that R really can see the right version of Python, and that one extra Python module is correctly installed and available to R to find out how well you’ve done, using: reticulate::py_available(TRUE) ## [1] TRUE reticulate::py_module_available(&quot;wx&quot;) ## [1] TRUE The outcome of this second command tells you if your system is ready to run the WriteR application. 10.4 Opening WriteR from BrailleR Opening WriteR is as easy as typing WriteR! Well almost. You have the option of specifying a filename; if that file exists, it gets opened for you, and if it doesn’t exist, then it gets created with a few lines already included at the top to help get you started. Try: WriteR(&quot;MyFirst.Rmd&quot;) 10.5 What can I do with WriteR? The window you are in has a number of menus, a status bar at the bottom and a big space in the middle for your work. Take a quick look at those menus; some will look familiar because they are common to many Windows applications. The file you have opened is a markdown file. It is just text which is why it is so easy to read. The file extension of Rmd means it is an R markdown file. There are several flavours of markdown in common use, but they are practically all the same except for some very minor differences. A markdown file can be converted into many file formats for distribution. These include HTML, pdf, Microsoft Word, Open Office, and a number of different slide presentation formats. Let’s make the HTML file now. 10.6 Our first HTML file Making your first HTML file is as easy as hitting the f5 key, or using one of the options in the Build menu. The variety of options are the commonly used ones in RStudio. Let’s just stick to making an HTML file for the time being. You can investigate other formats later. When the processing is underway, a second window will open which gives the same output that you would see printed in an R session window if you were processing R markdown files manually. If the last line says “done 0”, then everything processed properly; if it says “done 1” then there was an error to fix, so look through this log to see what went wrong. The processing of your R markdown document will use a suite of packages, primarily including the knitr (Xie 2018) and rmarkdown (???) packages. Press the f4 key to switch back to the main document editing window in WriteR. If the processing of the file “MyFirst.Rmd” was successful, then you will now have a file called “MyFirst.html” in your current working directory. You have several choices for finding the HTML file you have created: Navigate to the current working directory using your file browser. To find out where that is, type getwd() in the R window to see where the files really are located. You should see the file MyFirst.Rmd and once you have built it, the associated HTML file. Open that file in your browser. Use the browseURL() command in the R session. You will need to provide the filename, in quotes, for example browseURL(&quot;MyFirst.html&quot;) Use one of these methods to open the HTML file. Read through it to see how the markdown has been rendered. You may need to switch back and forth between the WriteR window and your browser to compare the plain text and the beautiful HTML. If you didn’t actually edit the R markdown file up to now then the output HTML file will be rather boring. Add in some text, or use the menus to see how to insert headings and other things. N.B. Changes in your R markdown file are not automatically converted into the HTML file. You must re-build the HTML, and refresh your browser to see the impact of any changes you make, both actions use the f5 key. 10.7 BrailleR commands used in this chapter We needed to use either GetPython27() and GetWxPython27() or GetPython3() to install the necessary software to allow us to run a Python script like WriteR. We then opened a new file using WriteR(). References "],
["AccessibleGraphs.html", "Chapter 11 Making Accessible Graphs 11.1 incomplete", " Chapter 11 Making Accessible Graphs While the initial aim of the BrailleR Project was to create a text description of a graph, there are many ways to explore graphs created in R by other means. This chapter introduces some techniques for creating or modifying graphs so that they can be investigated by a blind person without the assistance of a sighted person. 11.1 incomplete "],
["LookingAhead.html", "Chapter 12 The Work Ahead", " Chapter 12 The Work Ahead The BrailleR Project is likely to evolve over time. The work on the project will be dependent on interest being shown by blind users of R, and perhaps some willingness being shown by people who could make the work so much easier. Developments that meet specific requests from blind users are being addressed. For example, the request from one user to have the BrailleR package loaded in every session led to creation of a MakeRprofile() function; this function simplifies the experience for the user (a novice) for creation of the .Rprofile file in the current working directory. This is easier to explain to a novice than the process of altering the .Rprofile or .Rprofile.site files. A request for assistance getting braille labels onto graphs has brought forward the plans to address this issue within the BrailleR package. The experimental BRLThis() function has been included in the package, as well as a similar SVGThis() function to optimise the settings for creation of a version using a braille font and a structured SVG file for a graph. The BRLThis() function creates a pdf document that has been successfully embossed on two different models of embosser, while SVG files generated by the SVGThis() function have only the bare minimum of useful content at this stage. It may prove necessary for the BRLThis() function to be converted to a method like the SVGThis() functions so that the best results can be created for different graph types. At present, the SVGThis() is reliant on the existence of the hist() and boxplot() commands within the BrailleR package that are wrappers to the graphics package functions of the same name. It is my hope that I can encourage the R development core team to create more classes. The additions are almost trivial from their perspective, but the workload for me as a programmer will reduce markedly if I can write simpler code to interpret the graphs. Knowing what type of graph has been created by an object rather than writing code that makes a reasonable attempt at guessing what type of graph was created is a key example. To this end, it will prove easier to work with the graphs created by the xyplot() function from the lattice package than the standard plot() command. I will also need feedback from students and users of R, and perhaps their lecturers, tutors, and teachers, to see which ideas are working well for blind users. At present, the attempts being made are based on my own experiences and desires; I wanted functions to convert an R script to an R markdown file and a similr function to convert the history of commands to an Rmd file. The R2Rmd() and History2Rmd() functions were duly created; they have proven very useful in my work. I can only hoep others find them as useful. I am, therefore, seeking opportunities to share my work with blind users all over the world via a specially created email list for those people interested in how blind users can work with R{}. I believe that adding perspectives is a crucial pathway for the project’s development and all feedback is extremely welcome. A key contribution is possible in the area of choosing appropriate default text for the BrailleR output. The text representation needs to be more efficient than using R in its vanilla form. To this end, I have put some time into thinking about which text will be most suitable for an audience that will often listen to the output using synthetic speech, perhaps in the user’s second language, as well as the braille readers who may or may not be able to use contracted English braille. At first, I had thought this task would be made easier by reviewing resources created by transcribers who record books for the blind, but my investigations show that the descriptions used in spoken words do not always equate to efficient braille or synthetic speech and often provide more interpretation than I believe is appropriate in educational settings. Collaboration from others in any role will feed my own enthusiasm for the project, especially those whose skills and knowledge complement my own. The work of willing and helpful contributors has been gratefully received. In some instances, other researchers in the R community have inadvertently contributed to BrailleR because I have been able to adapt their work to meet the needs of blind users. "],
["references-3.html", "Chapter 13 References", " Chapter 13 References "]
]
