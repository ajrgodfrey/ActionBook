[
["index.html", "BrailleR in Action Preface", " BrailleR in Action A. Jonathan R. Godfrey 2018-06-06 Preface If blind students are to truly gain access to statistical analyses, they will need to be able to successfully complete a course in statistics at university level. To do this, they must learn how the graphical techniques used in the sighted world look and are used. Generation of tactile images can show blind students what a particular graph does in a general sense, but greater understanding will come from generating these graphs as part of an analysis — in the same way it does for sighted students. While sighted students can make use of a number of graphical user interfaces (GUIs), blind students are restricted to use of the command-line mode of operation or typing out an R script in full. One key benefit of the GUI mode of working is the ability to quickly generate basic numerical and graphical analyses. Blind students need to gain the same information as their sighted peers without expending too much additional time and energy. The BrailleR package aims to bridge this gap by delivering the range of analyses commonly found in introductory courses via a reduced set of commands. Once blind students have completed their first course in statistics, they may embark on research at a university, or head out into industry to apply their knowledge. Irrespective of the direction they choose, they will need certainty in being able to independently create graphs for the sighted readers of their work. Creation of tactile images that provide the same representation of the images to be placed in documents can provide a solution, but all too often blind people do not have access to the right software and hardware to generate tactile images for themselves with the immediacy that is required. The BrailleR package aims to provide textual information to the blind user in conjunction with the graph that would be placed in the final report. BrailleR does this by interpreting the object that is implicitly created whenever a graph is created in R. by creating an appropriate and concise text representation of the graph. In summary, this book presents the work included in the BrailleR package that will assist blind students successfully complete an introductory course in statistics when other software options fail them. Many of the functions support workflows that improve the efficiency of blind users at all levels of experience. I’ve tried a few ways to help get blind people using the BrailleR package and needed a place to combine the efforts easily. I don’t yet know if this e-book will turn into anything but a few webpages, but let’s see shall we? Jonathan Godfrey 0.0.1 Citation details Please refer interested parties to the online edition of this work at https://R-Resources.massey.ac.nz/BrailleRInAction/ When citing this work, please use the title, author, and date information on this page. The online version has ISBN978-0-473-41495-5 and is preferred for citation over other formats. The epub version has ISBN 978-0-473-41493-1 and pdf version has ISBN 978-0-473-41494-8; these fixed formats were created in October 2017. 0.0.2 Copyright information This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA. "],
["introduction.html", "Chapter 1 Introduction 1.1 Why will I use the BrailleR package as a novice? 1.2 Why will I use the BrailleR package if I am not a novice? 1.3 References", " Chapter 1 Introduction Access to information is crucial for a blind person’s success in education, but transferring the knowledge about the existence of techniques into actually being able to perform those tasks is what will make that blind person employable. This paper is based on the author’s experiences as a blind academic in statistics who has often been called on for advice by blind students studying statistics and their sighted lecturers wanting to provide the best possible support. Unfortunately, there is little information available in academic journals or the public domain to offer the statistics lecturer who is about to teach a blind student for the first time. At the 2009 Workshop on E-Inclusion in Mathematics and Sciences, I was able to meet other researchers and scientists who are also concerned about the low rate of blind people entering the sciences in a broad sense and the mathematical sciences in particular (Godfrey 2009) presented my first formalized summary of what I saw as the current state of affairs for blind people taking statistics courses; that work discussed what was possible in theory, but lacked evidence of what was happening in practice. A collaboration with the only other blind person to gain employment as a full-time Lecturer in Statistics led to a more comprehensive review of what we believe is the current state of affairs for blind students learning statistics. (???) present a wide range of issues that blind students and their teachers must overcome, often through use of the best software options available today. R (R Core Team 2018) has featured as a key element in my recommendations for teaching statistics to blind students (Godfrey 2009) because it offers the greatest opportunity for meeting the needs of blind users. An invitation to attend the second “Summer University” event was taken up in mid 2011; the purpose of this event was to show blind students and disability support staff from universities what software and hardware is available to improve the success rates of blind students entering the sciences. This was my first direct opportunity to show blind students how R could be used by them, and the relative merit that R has for them over alternative statistical software. I observed blind students working with R and struggling more than I thought was truly necessary. I knew I could do something about it and have spent a lot of time doing so ever since. An R Journal article (Godfrey 2013b) followed which exposed the needs of blind users to the R community and also announced the initial development of the BrailleR package. The BrailleR package is my attempt to help blind students and their lecturers. It is built on functions that I use to work as a lecturer in statistics. It aims to make up for the inability blind users have to work with the same extension tools their sighted peers are using, including the increasing number of graphical user interface (GUI) and integrated development environment (IDE) options. 1.1 Why will I use the BrailleR package as a novice? Blind users will want to use the BrailleR package while they are novice R users, but may also want to continue using some of the tools as their skill levels increase. Each of the following reasons for using the BrailleR package are expanded on by way of examples that go into more detail in subsequent chapters of this text. 1.1.1 BrailleR improves the accessibility of graphical information BrailleR converts standard graphs created by standard R commands into a textual form that can be interpreted by blind students who cannot access the graphs without printing the image to a tactile embosser, or who need the extra text to support any tactile images they do create. At present this is limited to only a few graph types found in base R functionality. An example of a histogram is presented in Chapter 4. 1.1.2 BrailleR helps gain access to the content of the R console BrailleR makes text output (that is visually appealing) more useful for a blind user who is reliant on synthesized speech or braille output to interpret the results. The first example of this kind presented in Chapter 4 shows how the summary statistics for a dataset can be made easier for a screen reader user. 1.1.3 BrailleR includes convenience functions Many analyses get repeated over and over again with different variables. Some people like a graphical user interface (GUI) but none of the GUIs developed for R to date are accessible by screen reader users. BrailleR includes some functions which generate pro forma analyses. When these functions are employed, they generate an HTML document that includes the analysis in an easy to use format. The R commands used to create the analysis are stored in an R script file so that a user can modify the commands if changes are necessary. These functions are introduced in Chapter 6. 1.2 Why will I use the BrailleR package if I am not a novice? I think some of the reasons for using the package while you are a novice R user remain relevant to more-experienced users too, but perhaps the main reason for continuing to use BrailleR is that of efficiency. The convenience functions introduced in Chapter 6 give you a starting point for analyses. Behind those convenience functions was an R markdown file that generated the R script and the HTML document. Getting into markdown is a great idea and will not take you long to learn. BrailleR also includes some tools for helping run your R jobs without running R. Experienced users do this all the time so these tools aren’t really meant for blind users alone, but as blind people often find little inefficiencies tiresome, I’ve incorporated the tools I use for my own efficiency when I think they might prove useful to other blind people. In summary, the BrailleR package is my attempt to help blind students and their lecturers. It is built on functions that I use to work as a lecturer in statistics. It aims to make up for the inability blind users have to work with the same extension tools their sighted peers are using, including the increasing reliance on GUIs and integrated development environment (IDE) options. 1.3 References References "],
["History.html", "Chapter 2 History of the BrailleR Project 2.1 My background 2.2 Getting the BrailleR Project started 2.3 The starting point example 2.4 Why just plain text? 2.5 Exposure of the BrailleR package outside the blind community 2.6 Reviewing statistical software 2.7 Attendance at UseR conferences 2.8 The ongoing work 2.9 Acknowledgements 2.10 References", " Chapter 2 History of the BrailleR Project I am one of only two blind people in the world today who gained employment as full-time lecturers of statistics, that is, teaching statistics classes and doing research in theoretical matters as against applying statistical techniques. For years, I tried to keep my blindness separate from my research but I took some opportunities that came my way and heeded the advice of some colleagues to put more energy into improving the ability of blind students around the world to have greater access to statistics courses and statistical understanding. This document shows you a bit more insight into how I (with the help of some useful collaborations) got the BrailleR package to where it is now. 2.1 My background My adult life has been centred around Massey University, initially as an extramural student and then studying on campus. I have undergraduate degrees in Finance and Operations Research, a Master’s degree in Operations Research and a PhD in Statistics. I was a Graduate Assistant from 1998 to 2002, and then Assistant Lecturer from January 2003 to June 2004 when I became a Lecturer in Statistics. I was promoted to Senior Lecturer in late 2014. While I don’t find it important, I do get asked about the condition that caused my blindness. It is Retinitis Pigmentosa. I do have some light perception, and can make use of it in familiar surroundings for orientation but it has no value to me for reading anything at all. I chose to work with screen reading software when I started university and obtained my first computer because my residual vision at the time was limiting my reading speed. I have therefore operated a computer as a totally blind user throughout my adult life. I did not learn braille until after I completed my PhD. This might seem strange, but there was very little material in a suitable digital format for me to read throughout my student life. Things have changed and I now spend a lot more time reading material and doing programming where the accuracy of braille is absolutely necessary. Braille has now become a very important part of my working life and I have a braille display connected to my computer most of the time. 2.2 Getting the BrailleR Project started I used to keep my research interests separate from my blindness, but I was regularly called upon to discuss how a blind person could study and teach Statistics by many people within New Zealand and occasionally from overseas. In 2009, I attended the Workshop on E-Inclusion in Mathematics and Science (WEIMS09) where I met other people interested in improving the success rates of blind students in the mathematical sciences. My paper was about accessibility of statistics courses, but I did point out the usefulness of R in preference to other tools I had used to that point in time (Godfrey 2009). I discovered that there is room for me to take a leading role in the development of ideas that can help other blind people learn about statistical concepts. I have been invited to all six Summer University events run by the organizers of the International Conference on Computers Helping People (ICCHP), but have been unable to attend twice due to the high cost of transporting me to Europe. I have delivered an introductory workshop on using R at four of these events [Godfrey (2011); Godfrey (2013a); Godfrey (2014b), and Godfrey (2016b). Having observed the attendees at the 2011 Summer University as they came to grips with R, I knew there was more I could do to help them and other blind students. I started work on the BrailleR package (Godfrey et al. 2018) in the second half of 2011 and first proposed it could work for blind users at the Digitisation and E-Inclusion in Mathematics and Science (DEIMS12) workshop held in Tokyo during February 2012 (Godfrey 2012b). I wasn’t to know the value of another talk I gave at DEIMS12 for another two years; this second talk and associated conference paper focused on how I was using Sweave to create accessible statistical reports for me and more beautifully formatted ones for my statistical consulting clients. (Godfrey 2012a). I now know that the groundwork I had done contributed to my desire to present my workflow as a workshop at the 5th Summer University in 2014 (Godfrey 2014d). It also stood me in good stead for the work that followed on the BrailleR package as it developed in late 2014 and early 2015. 2.3 The starting point example The basic graph that has been used for almost every presentation of the BrailleR package is a histogram. There is a more detailed example, but the following commands create a set of numbers that can be kept for further processing once the graph has been created. It is the re-processing of these numbers that leads to the text description that follows. library(BrailleR) ## The BrailleR.View, option is set to FALSE. ## ## Attaching package: &#39;BrailleR&#39; ## The following objects are masked from &#39;package:graphics&#39;: ## ## boxplot, hist ## The following object is masked from &#39;package:utils&#39;: ## ## history ## The following objects are masked from &#39;package:base&#39;: ## ## grep, gsub x=rnorm(1000) VI(hist(x)) Figure 2.1: A histogram of 1000 random values from a normal distribution ## This is a histogram, with the title: Histogram of x ## &quot;x&quot; is marked on the x-axis. ## Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, 3, and 4 ## There are a total of 1000 elements for this variable. ## Tick marks for the y-axis are at: 0, 50, 100, and 150 ## It has 14 bins with equal widths, starting at -3 and ending at 4 . ## The mids and counts for the bins are: ## mid = -2.75 count = 5 ## mid = -2.25 count = 15 ## mid = -1.75 count = 43 ## mid = -1.25 count = 92 ## mid = -0.75 count = 157 ## mid = -0.25 count = 189 ## mid = 0.25 count = 184 ## mid = 0.75 count = 160 ## mid = 1.25 count = 83 ## mid = 1.75 count = 54 ## mid = 2.25 count = 15 ## mid = 2.75 count = 2 ## mid = 3.25 count = 0 ## mid = 3.75 count = 1 This first example showed me what was possible if only I could get a few things sorted out. All histograms are created by a function that stores the results (both numeric and text details) and calls this stored set of values a “histogram”. The main issue is that storing the set of details is not consistent in R, nor is the fact that the stored object gets given a “class” to tell me what type of object it is. This problem haunted me for quite some time because I was talking to the wrong people about the problem; it was time to find people that held the solution instead of talking to the people that would benefit if a solution was found. 2.4 Why just plain text? The first initiative of BrailleR was to turn information presented in a visual medium into a medium that is simple to work with, efficient, and complementary to the skill set of as wide a group of blind people as possible. With this in mind, a plain text solution for gaining access to visual information was favoured above tactile images as there is no need for any additional adaptive technology (hardware or software) over that used for the blind person’s other work. Information presented in text is readable in braille or heard via synthetic speech, and is therefore only limited to the user’s skill set. Other research projects are progressing the creation of tactile images that replace the printed graphics sighted people deal with all the time in statistical work. Tactile images do have a role to play in educating blind people and providing them with access to information, but their greatest drawback remains their lack of immediacy. Rendering a graphic into a master file complete with braille labels, and then producing this for consumption are tasks receiving much attention, but the value for such efforts is probably greatest for situations where one master can be used to create multiple copies for wider consumption such as the conversion of textbooks into braille. Some preliminary investigations into the ability to create tactile image versions of graphs created in R have been made as part of the wider BrailleR Project. Under a sighted paradigm, many graphs in statistical work are developed for one-time use and discarded almost immediately. It may be some time until the effectiveness of tactile image hardware and software is ready to deliver this outcome for all blind users of R; in the meantime, we must find ways of gaining access to the graphical information without reliance on another person’s ability to translate the visual medium into something more useful for us. We must also acknowledge here that the number of blind people with their own tactile image hardware and software is regrettably low. Even though it is possible to directly export a graph created in R to an embosser, use of this practice is not yet commonplace. Perhaps we can look forward to the time when most blind people can have access to a refreshable tactile display that can display two-dimensional images that compare with the best that is possible in hard copy today. Sonification is considered by many to be an alternative to production of tactile images for a blind audience. Work on sonifying statistical graphs is being considered, but is at present best described as experimental. Several concerns must be overcome before sonification can be claimed a truly useful method for interpretting data. There is an assumption made frequently by correspondents with this author that lack of vision implies a blind person has superior aural ability . This may be true for some blind people, but it is not universally true. We must be sure that the interpretation gained through sound is comparable to the interpretation that a graph in visual form would convey. Proponents of sonification often suggest that sound provides a different interpretation to a visual display. If they are correct, then sonification cannot be a true alternative to a visual graph. The same, of course, can be said for the difference between the interpretation obtained through touching tactile images. In both cases, the solution for blind users must be that the visual representation can be converted to a useful format when blind users need it, without the assistance of a sighted person to check the validity of the outcome. 2.5 Exposure of the BrailleR package outside the blind community It was obvious to me that getting the word out to the masses about the usefulness of R for blind students and professionals was crucial. I started to compile my notes built up from various posts made to email groups and individuals over the years, as well as the lessons I learned from attendance at the 2nd Summer University event. This led to the eventual publication of my findings in (Godfrey 2013b). I know that this was a worthwhile task because it was read by teachers of blind students who were already using R for their courses. One such person tested R and a screen reader and managed to find a solution to a problem posed in Godfrey (2013b) which led to an addendum (Godfrey and Erhardt 2014). I presented some of my work via a poster (Godfrey 2013c) at the NZ Statistical Association conference in Hamilton during November 2013. This ‘poster’ presentation was developed as a multimedia presentation so that the audience could observe video footage, handle tactile images and be able to talk with me about the BrailleR Project. The plan to get talking with people instead of talking at them worked and I started a really useful collaboration with Paul Murrell from the University of Auckland. His major contributions didn’t feature in the BrailleR package for some time, but we’re making some really nice progress. Paul is an expert in graphics, especially their creation and manipulation in R. Our discussions about graphics has yielded a few titbits for my own work that have been tested for the package. We’ve been working on how to make scalable vector graphics that can be augmented to offer blind users greater interactivity and therefore hopefully greater understanding (see Godfrey and Murrell 2016). 2.6 Reviewing statistical software I have been asked about the use of R in preference to other statistical software by many blind students, their support staff, and their teachers. Eventually I joined forces with the only other blind person to gain employment as a lecturer of statistics (Theodor Loots, University of Pretoria) to compare the most commonly used statistical software for its accessibility (Godfrey and Loots 2014). I summarised this paper at the 5th Summer University event (Godfrey 2014a), and offered a similar presentation at the 6th Summer University event (Godfrey 2016a) with a few updates. It is important to keep abreast of developments, because the statistical software changes, and so does the screen reading software that gives us access to the mainstream statistical software. 2.7 Attendance at UseR conferences On my way to the 5th Summer University event, I managed to attend the principal conference for R users (UseR!2014) in Los Angeles where I presented my findings (Godfrey 2014c). Perhaps the most valuable outcome of this conference was the ability to attend a tutorial on use of the knitr package (Xie 2018) and then talk to its author, Yihui Xie. I’d already seen the knitr package before attending UseR!2014 and implemented it for some of my teaching material by updating the Sweave documents already in use. The real value came in realising what I could probably do if I used R markdown to do a few things I had found very hard using the Sweave way of working. More specifically, generating an R markdown file (Rmd) from an R script was much easier than generating a Sweave file (Rnw). Writing the convenience functions for the BrailleR package started to look very achievable at this point, and so work began. I dug out some old work that wasn’t fit for sharing and converted it to the markdown way of working. There has been sufficient progress in the BrailleR Project that I presented it at UseR!2015 (Godfrey 2015). In 2016, I presented my findings on writing (and therefore reading) R markdown documents for (and by) blind users (Godfrey and Bilton 2016). 2.8 The ongoing work The introduction of R markdown to the BrailleR package made a huge difference. I’ve been able to write enough example code that once I found a friendly postgraduate student (Timothy Bilton) to put some time into it, we’ve managed to add more convenience functionality. Timothy improved some of my earlier work and tried a few things of his own. This left me with the time to add increased functionality for helping blind users get into markdown for themselves. One of my irritations of working with markdown is that everyone else seems to write markdown and check their findings using RStudio (RStudio 2013), which remains inaccessible for me and other screen reader users. I took an old experiment where I wrote an accessible text editor in wxPython, and with the help of a postgraduate student from Computer Science (James Curtis) we’ve modified it to process Rmd files. The WriteR application is now beyond experimental but there is still more to do on making it truly useful (Godfrey and Curtis 2016). In 2018, I received a great deal of assistance from Marshall Flax who was able to help develop WriteR into a tool that could be very useful to blind people wishing to write and process R markdown files. 2.9 Acknowledgements Contributions to the BrailleR Project are welcome from anyone who has an interest. I will acknowledge assistance in chronological order of the contributions I have received thus far. Greg Snow was the first person to assist when he gave me copies of the original R code and help files for the R2txt functions that were part of his TeachingDemos package (Snow 2016). The Lions clubs of Karlsruhe supported my attendance at the 3rd Summer University event in 2013. This gave me the first opportunity to put the package in front of an audience that I hope will gain from the package’s existence. I’ve already mentioned the following contributors above:Paul Murrell, Yihui Xie, Timothy Bilton, James Curtis, and Marshall Flax. I also need to acknowledge the value of attending the Summer University events. I gain so much from my interactions with the students who attend, the other workshop leaders who give me feedback, and the other professionals who assist blind students in their own countries. 2.10 References References "],
["GettingStarted.html", "Chapter 3 Getting started with BrailleR 3.1 Accessibility of statistical software 3.2 Accessibility of graphics in statistical software 3.3 Accessibility of R 3.4 Installing the BrailleR package 3.5 What else do you need? 3.6 BrailleR commands used in this chapter 3.7 References", " Chapter 3 Getting started with BrailleR The BrailleR package has been created for the benefit of blind people wishing to get more out of R than it already offers — which is actually quite a lot! 3.1 Accessibility of statistical software A description of what makes statistical software accessible to the blind was given by (Godfrey and Loots 2014). Many of the problems blind people face are a consequence of the failure of the specialist screen reading software we use to interact with graphical user interfaces. Many software applications are making use of graphics when once the information would be presented in text form with an accompanying graph. — SPSS (???) is an example of this, and to a lesser extent so is the standard edition of Minitab (???). The output from Minitab Express (???) is a prime example of the worst possible presentation of information that was originally text; this product generates graphics that include text which is not readable by a blind person for all of its statistical output. The speech output software used by blind people can only interpret information that is text. As a guide, if the individual text in a window cannot be highlighted using the keyboard and not the mouse, then it is likely that this text will not be read for the blind user. It is true that some add-on packages for R also generate unreadable output, but as illustrated below, this is less of an issue than for software like SPSS or Minitab. (Godfrey and Loots 2014) gave more detailed scrutiny of R, SAS (SAS Institute Inc. 2010) , SPSS, and Minitab. Of these four applications, R and SAS were clearly superior to SPSS and the standard edition of Minitab. Some software applications have retained their historical links to the days when graphs and tables were rendered in well controlled monospace fonts — Minitab for example. In such applications the user may still be able to produce an ASCII graphic instead of the more commonly used high resolution graphs expected of today’s software (and user). In contrast, SAS and SPSS can use HTML to present information in well-formatted tables. These output windows are preferred by blind users over the graph window displays but sometimes the amount of information is not easily understood. Presentation of output is often read by eye in a vertical direction, while speech output software will read line by line. Take for example, a multiple regression where the sighted reader may scan down the list of \\(p\\)~values in the right hand column; the same information being read aloud in line by line style could prove quite difficult to interpret. Blind users can use combinations of keys to move around HTML tables to speed up this process and avoid reading the intervening columns of output. While SPSS and SAS can deliver formatted HTML as a matter of course, R users must resort to the add-on packages, many of which are available on CRAN. 3.2 Accessibility of graphics in statistical software Access to graphical representations of information from mathematical or statistical software is quite limited, and therefore limits the blind user’s capacity. To this author’s knowledge, no mathematical or statistical software has the capability of directly linking to any hardware or software solutions that make the information presented in graphs immediately available. The scalable vector graphic (SVG) format can be used to present a graphic with text embedded into the file for creating access for a blind user (Bulatov and Gardner 2004,GardnerBulatov2010SVG). Only a small number of statistical software applications have the capacity to create SVG files, but this capacity does not in itself create access because the text that makes them accessible must be added somehow; generally this is a manual process. The World Wide Web Consortium has a recommendation on the use of SVGs in web content (???) and a number of add-on packages for R make use of SVG because of the opportunity to enrich a graphic’s interactivity in webpages; see (Murrell and Potter 2014) for a more detailed discussion of these packages and their functionality. Of particular note is that there are different ways to create an SVG and care must be taken if the maximum accessibility for blind users is ever to be achieved. In R, a graph can be saved as an SVG using the svg() command, but this approach uses the Cairo SVG format; this has the unfortunate outcome that text is not always preserved as a string, and some shapes are represented by an unstructured set of straight lines (Gardner and Bulatov 2010). Retention of text as strings is crucial if modifications such as changing the font of any text to the braille font of a user’s choosing is to be managed easily. Use of the gridSVG package (Murrell and Potter 2014) does lead to creation of SVG files that do keep strings of text intact and a hierarchy of graphical elements. These SVG files are more easily modified to create accessibility for blind users that have the technology to interpret them (Gardner and Bulatov 2010). Any graph created in R using functions from the graphics package will need to be converted to the grid package system for generating graphics through use of the gridGraphics (Murrell 2015) package before they are exported in SVG format. Existence of the gridSVG and gridGraphics packages means that it should be possible to automate the creation and addition of the necessary text information to the SVG so that the need for human intervention is minimised. Add-on scripts for screen reader software, such as JAWS (Freedom Scientific 2018), that attempt to interpret the graphs created by common spreadsheet software has been tried in the past. One major problem that results from the creation of these add-on scripts is that of maintenance; unfortunately, the add-on scripts for screen reader software support of spreadsheet applications has not kept pace with the developments of those applications sufficiently enough to give blind people access to the full range of graphs. Sporadic effort has been made at providing access to statistical software through the creation of add-on scripts for screen readers, but little effort was ever given to creating access to the content of graphics. It is unfortunate that these have also not been sufficiently maintained. In this respect the use of R or SAS currently hold an advantage over other commonly used software (notably SPSS and Minitab) for the blind user because no additional scripts for the screen reading software are required. (Godfrey and Loots 2014). R and SAS also work well with the open source screen reader called NVDA (NVDA Team 2018). In conclusion, it seems that until such time as adaptive technology for creating immediate access via tactile images is commonly available, other solutions will continue to be relevant. In fact, even once the immediacy issue is overcome, there will be a place for solutions such as the BrailleR package as a complementary solution rather than a substitute. 3.3 Accessibility of R (Godfrey 2013b) documented the ability to use R almost immediately after installation; only one minor change is recommended and can be achieved in less than a minute even when explained via email or a telephone call. For users of the Windows operating system, up until Windows XP, I always recommended running R in a terminal window instead of the GUI; the shortcut placed on the Windows desktop would then need to be pointed to Rterm.exe instead of Rgui.exe. Macintosh and Linux users are operational with no special actions required. Users of Windows Vista or Windows 7 did have an additional challenge of what appeared to be the screen locking up, or more exactly, the screen reader software “losing focus” in the R terminal window. The solution for this problem, as documented in (Godfrey and Erhardt 2014), was to hit the Alt key. Blind users now need to compare the combinations of screen reader and the terminal versus the GUI. The decision should be made by the individual user after some experimentation; their decision may depend on the skill level they have with their prefered screen reader and should be revisited at a later date. 3.4 Installing the BrailleR package To use the functionality of the BrailleR package you need to have it installed. The package has several dependencies so installation from the CRAN repository is recommended. This would be done by issuing the following two commands in an R session: chooseCRANmirror(ind=1) install.packages(&quot;BrailleR&quot;) If for some reason you have difficulty with the above commands, you can install the BrailleR package using a zip file version available from a CRAN repository or the latest version on GitHub. From time to time, you should check that you are using the most recent version of the BrailleR package. You can update all installed packages using the commands: chooseCRANmirror(ind=1) update.packages(ask=FALSE) Once you’ve got the package installed, you still need to get it running in your current R session by issuing one last command. When you issue the first of the following lines, the package start messages will also appear. library(BrailleR) You’re ready to go! 3.4.1 Some initial setting up instructions When you first use the library(BrailleR) command, you will see some start up messages and a question. The rules of R packages include not writing to the user’s hard drive without expressly asking them for permission to do so. If you do not want a folder for your BrailleR files then use the temporary folder which will be removed when you end your R session. This will mean you need to answer the question over the location of the MyBrailleR folder next time you issue the library(BrailleR) command though. The welcome message from BrailleR suggests you issue the GetGoing() command. This will ask you a few questions that will help personalise your use of the BrailleR package. We will see how to alter these settings in Chapter blah later so don’t panic if you don’t do it all right the first time. You can re-issue the GetGoing() command again at any time. The book you are reading now can be reached from your R session by issuing the command BrailleRInAction(). That might seem a bit much, but do remember you can use tab completion to avoid typing the whole command name out in full. You will probably need no more than B, r, a, then tab (which adds the rest of BrailleR), then I and one last tab; add the opening and closing parentheses and press the Enter key. This will open the front page of the book in your browser. A similar command, BrailleRHome(), will open the BrailleR Project home page. Itis all too easy to feel you’re doing it on your own, which even the most accomplished people have experienced. I put the ThankYou() command in the BrailleR package so that it would be easy to send me a message to tell me about your experiences as a blind person using R or to ask for help; it starts an email message to me. I’m not the only blind person out there using R, and many of us are on an email list so that we can share ideas and solutions for problems, many of which are specific to blind users. The JoinBlindRUG() command will start the email needed to join the BlindRUG email list. 3.5 What else do you need? You obviously have R installed or an intention to do so soon if you are reading this document. Aside from R and the add-on packages that BrailleR needs, there are no other software requirements. There are several optional software installations that could make life easier if they are installed before you need them. In order of necessity, they are: 3.5.1 The document converter — pandoc BrailleR requires the very useful file converter called pandoc. Get it from the pandoc download page 3.5.2 The principal integrated development environment — RStudio It is a good idea to install RStudio, even if you can’t actually use it as a blind person using screen reading software. The reason is that RStudio installs a few other useful tools that we will make use of by other means. Get it from the RStudio download page 3.5.3 One programming language — Python WriteR is a simple text editor written in wxPython that needs Python27 and wxPython. Unfortunately, they are two separate downloads at present. You do not need this editor so do not install Python unless you are really keen. Windows users can obtain an executable file by issuing GetWriteR() once the BrailleR package has been successfully installed. More on this in Chapter #WriteR 3.6 BrailleR commands used in this chapter The only BrailleR command actually recommended in this chapter was GetGoing(). You might find it useful to use BrailleRHome() and BrailleRInAction() from time to time, but you’re already reading the book that the second of these commands opens. The ThankYou() and JoinBlindRUG() commands should be used when you want to connect with me, or other blind R users. At this stage it is recommended that you install any additional software manually when it is required. 3.7 References References "],
["VI.html", "Chapter 4 Some basic examples 4.1 Histograms 4.2 Basic numerical summaries 4.3 BrailleR commands used in this chapter", " Chapter 4 Some basic examples This chapter presents some examples of text output generated by the VI() command of the BrailleR package. These examples generate output that is displayed in the R session just like any output from standard R commands. Please note however that not all VI() commands behave in this fashion; some more advanced uses of VI() are discussed in a later chapter. You will need the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the command library(BrailleR) now. 4.1 Histograms The first and most commonly used example demonstrating the value of the BrailleR package to a blind user is the creation of a histogram. x=rnorm(1000) VI(hist(x)) Figure 2.1: A histogram of 1000 random values from a normal distribution This is a histogram, with the title: Histogram of x &quot;x&quot; is marked on the x-axis. Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, and 3 There are a total of 1000 elements for this variable. Tick marks for the y-axis are at: 0, 50, 100, 150, and 200 It has 12 bins with equal widths, starting at -3 and ending at 3 . The mids and counts for the bins are: mid = -2.75 count = 6 mid = -2.25 count = 12 mid = -1.75 count = 52 mid = -1.25 count = 87 mid = -0.75 count = 142 mid = -0.25 count = 225 mid = 0.25 count = 199 mid = 0.75 count = 151 mid = 1.25 count = 75 mid = 1.75 count = 38 mid = 2.25 count = 10 mid = 2.75 count = 3 The VI() command actually calls the VI.histogram() command as the hist() command creates an object of class “histogram”. This means we can tailor the output to the information needed for any histogram created using the hist() command. 4.1.1 Important features The VI() command has added to the impact of issuing the hist() command as the actual graphic is generated for the sighted audience. The blind user can read from the text description so that they can interpret the information that the histogram offers the sighted world. The above example showed the standard implementation of the hist() function. The hist() function of the graphics package does not store the additional arguments that improve the visual attractiveness. The solution (perhaps temporary) is to mask the original function with one included in the BrailleR package that calls the graphics package function, and then adds extra detail for any added plotting arguments. This is best illustrated using the example included in the BrailleR::hist() function. example(hist) hist&gt; x=rnorm(1000) hist&gt; # the stamdard hist function returns hist&gt; MyHist=graphics::hist(x, xlab=&quot;random normal values&quot;, main=&quot;Example histogram (graphics package)&quot;) hist&gt; #dev.off() hist&gt; MyHist $breaks [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 $counts [1] 5 28 37 85 151 201 208 139 74 49 19 4 $density [1] 0.010 0.056 0.074 0.170 0.302 0.402 0.416 0.278 0.148 0.098 0.038 [12] 0.008 $mids [1] -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 2.25 [12] 2.75 $xname [1] &quot;x&quot; $equidist [1] TRUE attr(,&quot;class&quot;) [1] &quot;histogram&quot; hist&gt; # while this version returns hist&gt; MyHist=hist(x, xlab=&quot;random normal values&quot;, main=&quot;Example histogram (BrailleR package)&quot;) hist&gt; #dev.off() hist&gt; MyHist $breaks [1] -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 $counts [1] 5 28 37 85 151 201 208 139 74 49 19 4 $density [1] 0.010 0.056 0.074 0.170 0.302 0.402 0.416 0.278 0.148 0.098 0.038 [12] 0.008 $mids [1] -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 2.25 [12] 2.75 $xname [1] &quot;x&quot; $equidist [1] TRUE $main [1] &quot;Example histogram (BrailleR package)&quot; $xlab [1] &quot;random normal values&quot; $ExtraArgs $ExtraArgs$main [1] &quot;Histogram of x&quot; $ExtraArgs$xlab [1] &quot;x&quot; $ExtraArgs$ylab [1] &quot;Frequency&quot; $ExtraArgs$sub [1] &quot;&quot; $NBars [1] 12 $par $par$xaxp [1] -3 3 6 $par$yaxp [1] 0 200 4 $xTicks [1] -3 -2 -1 0 1 2 3 $yTicks [1] 0 50 100 150 200 attr(,&quot;class&quot;) [1] &quot;Augmented&quot; &quot;histogram&quot; hist&gt; # The VI() method then uses the extra information stored hist&gt; VI(MyHist) This is a histogram, with the title: Histogram of x &quot;x&quot; is marked on the x-axis. Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, and 3 There are a total of 1000 elements for this variable. Tick marks for the y-axis are at: 0, 50, 100, 150, and 200 It has 12 bins with equal widths, starting at -3 and ending at 3 . The mids and counts for the bins are: mid = -2.75 count = 5 mid = -2.25 count = 28 mid = -1.75 count = 37 mid = -1.25 count = 85 mid = -0.75 count = 151 mid = -0.25 count = 201 mid = 0.25 count = 208 mid = 0.75 count = 139 mid = 1.25 count = 74 mid = 1.75 count = 49 mid = 2.25 count = 19 mid = 2.75 count = 4 4.1.2 Warning The VI() function is partially reliant on the use of the hist() function that is included in the BrailleR package. If a histogram is created using a command that directly links to the original hist() command found in the graphics package, then the VI() command’s output will not be as useful to the blind user. This mainly affects the presentation of the title and axis labels; it should not affect the details of the counts etc. within the histogram itself. This behaviour could arise if the histogram is sought indirectly. If for example, a function offers (as a side effect) to create a histogram, the author of the function may have explicitly stated use of the hist() function from the graphics package using graphics::hist() instead of hist(). Use of graphics::hist() will bypass the BrailleR::hist() function that the VI() command needs. This should not create error messages, but may result in some strange and possibly undesirable output. 4.2 Basic numerical summaries The standard presentation of a summary of a data frame where each variable is given its own column is difficult for a screen reader user to read as the processing of information is done line by line. For example: summary(airquality) Ozone Solar.R Wind Temp Min. : 1.00 Min. : 7.0 Min. : 1.700 Min. :56.00 1st Qu.: 18.00 1st Qu.:115.8 1st Qu.: 7.400 1st Qu.:72.00 Median : 31.50 Median :205.0 Median : 9.700 Median :79.00 Mean : 42.13 Mean :185.9 Mean : 9.958 Mean :77.88 3rd Qu.: 63.25 3rd Qu.:258.8 3rd Qu.:11.500 3rd Qu.:85.00 Max. :168.00 Max. :334.0 Max. :20.700 Max. :97.00 NA&#39;s :37 NA&#39;s :7 Month Day Min. :5.000 Min. : 1.0 1st Qu.:6.000 1st Qu.: 8.0 Median :7.000 Median :16.0 Mean :6.993 Mean :15.8 3rd Qu.:8.000 3rd Qu.:23.0 Max. :9.000 Max. :31.0 The VI() command actually calls the VI.data.frame() command. It then processes each variable one by one so that the results are printed variable by variable instead of summary statistic by summary statistic. For example: VI(airquality) The summary of each variable is Ozone: Min. 1 1st Qu. 18 Median 31.5 Mean 42.1293103448276 3rd Qu. 63.25 Max. 168 NA&#39;s 37 Solar.R: Min. 7 1st Qu. 115.75 Median 205 Mean 185.931506849315 3rd Qu. 258.75 Max. 334 NA&#39;s 7 Wind: Min. 1.7 1st Qu. 7.4 Median 9.7 Mean 9.95751633986928 3rd Qu. 11.5 Max. 20.7 Temp: Min. 56 1st Qu. 72 Median 79 Mean 77.8823529411765 3rd Qu. 85 Max. 97 Month: Min. 5 1st Qu. 6 Median 7 Mean 6.99346405228758 3rd Qu. 8 Max. 9 Day: Min. 1 1st Qu. 8 Median 16 Mean 15.8039215686275 3rd Qu. 23 Max. 31 4.2.1 Important features Note that in this case, the blind user could choose to present the summary of each variable as generated by the VI() command, or the output from the standard summary() command. There is no difference in the information that is ultimately presented in this case. 4.3 BrailleR commands used in this chapter The only explicit command from the BrailleR package used in this chapter was the VI() command. "],
["NewGraphs.html", "Chapter 5 New BrailleR commands for making basic graphs 5.1 Background 5.2 Example: A histogram 5.3 Scatter plots 5.4 BrailleR commands used in this chapter", " Chapter 5 New BrailleR commands for making basic graphs This chapter introduces some of the new commands found in the BrailleR package that are substitutes for other functions found in the base distribution of R. You can jump ahead to the examples, but there is some theory needed to explain how the BrailleR package does the extra work it does, and why we need to use these substitute commands. You will need the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the command library(BrailleR) now. 5.1 Background In Chapter 4, we saw creation of a histogram using the hist() command. The hist() command used for many years is found in the graphics package and has its own plot() command called plot.histogram() as well. This plot() command is actually a family of commands that all start withplot.*() where the star is replaced by the type of object that is being plotted. We use this plot() command all the time to give us plots for different reasons. When we fit a regression model, we need to create various plots of the residuals and it is done using plot() which actually employs plot.lm() in the background to do the work. The family of commands are referred to as “methods” and the types of objects being worked on are called “classes”. We need a little more background before diving into the various new commands BrailleR offers. 5.1.1 Methods and classes Methods and classes are important ideas because we can write a method function that says how we want an object with a stated class to be processed. When we create a histogram with the hist() command we can store an object of class “histogram”, and when we create a regression model using lm() we create an object of class “lm”. This class attribute is stored when many objects are created by R commands and many classes have methods written for them such as print(), summary(), and plot(). If data is stored with a specified class attribute, such as a time series with class “ts”, we will generate different results from employing the methods. A data.frame is itself of class “data.frame”, a matrix is of class “matrix”, but rather confusingly, a vector is not of class “vector”. Vectors are assigned class attributes that depend on the type of data being stored, being “integer”, “numeric”, “logical”, “character”, etc. 5.1.2 Who cares about classes anyway? It is a reasonable question to ask. BrailleR cares because the functions written such as the VI() command used in Chapter 4 is actually a family of commands. The VI() commands called actually refered to the VI.histogram() and VI.data.frame() commands to generate output that is sensitive to the object of interest. So for the VI() command to do the processing necessary to extract the information that is pushed into a graphic or textual output, we need to know what kind of object was being created. For the examples shown in Chapter 4, that was done with the standard R commands used when creating the histogram and the data.frame we used. Well that’s almost true. The standard hist() command from the base distribution of R does assign the class “histogram” to the stored object, but it doesn’t have all the necessary information in it to replicate a plotted histogram. The solution is to create a new hist() command in the BrailleR package that does all the work of the original function and does add the details we want to help describe the histogram being plotted. 5.2 Example: A histogram One of the easiest ways to demonstrate code snippets is to include them in the help documentation of the function. Running these examples is possible using the example() command. In this example, we see that use of the original hist() from the graphics package yields the same graph as the BrailleR package version, but that the additional text for such items as titles and axis labelling used in the text description are only added by BrailleR::hist(). Running the command, example(hist) command will give you the following: &gt; x = rnorm(1000) &gt; MyHist = graphics::hist(x, xlab = &quot;random normal values&quot;, + main = &quot;Example histogram (graphics package)&quot;) Figure 5.1: testing examples &gt; MyHist $breaks [1] -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 $counts [1] 3 4 18 40 90 155 197 193 138 93 43 16 10 $density [1] 0.006 0.008 0.036 0.080 0.180 0.310 0.394 0.386 0.276 0.186 0.086 [12] 0.032 0.020 $mids [1] -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 [12] 2.25 2.75 $xname [1] &quot;x&quot; $equidist [1] TRUE attr(,&quot;class&quot;) [1] &quot;histogram&quot; &gt; MyHist = hist(x, xlab = &quot;random normal values&quot;, main = &quot;Example histogram (BrailleR package)&quot;) Figure 5.1: testing examples &gt; MyHist $breaks [1] -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 1.5 2.0 2.5 3.0 $counts [1] 3 4 18 40 90 155 197 193 138 93 43 16 10 $density [1] 0.006 0.008 0.036 0.080 0.180 0.310 0.394 0.386 0.276 0.186 0.086 [12] 0.032 0.020 $mids [1] -3.25 -2.75 -2.25 -1.75 -1.25 -0.75 -0.25 0.25 0.75 1.25 1.75 [12] 2.25 2.75 $xname [1] &quot;x&quot; $equidist [1] TRUE $main [1] &quot;Example histogram (BrailleR package)&quot; $xlab [1] &quot;random normal values&quot; $ExtraArgs $ExtraArgs$main [1] &quot;Histogram of x&quot; $ExtraArgs$xlab [1] &quot;x&quot; $ExtraArgs$ylab [1] &quot;Frequency&quot; $ExtraArgs$sub [1] &quot;&quot; $NBars [1] 13 $par $par$xaxp [1] -3 3 6 $par$yaxp [1] 0 200 4 $xTicks [1] -3 -2 -1 0 1 2 3 $yTicks [1] 0 50 100 150 200 attr(,&quot;class&quot;) [1] &quot;Augmented&quot; &quot;histogram&quot; &gt; VI(MyHist) This is a histogram, with the title: Histogram of x &quot;x&quot; is marked on the x-axis. Tick marks for the x-axis are at: -3, -2, -1, 0, 1, 2, and 3 There are a total of 1000 elements for this variable. Tick marks for the y-axis are at: 0, 50, 100, 150, and 200 It has 13 bins with equal widths, starting at -3.5 and ending at 3 . The mids and counts for the bins are: mid = -3.25 count = 3 mid = -2.75 count = 4 mid = -2.25 count = 18 mid = -1.75 count = 40 mid = -1.25 count = 90 mid = -0.75 count = 155 mid = -0.25 count = 197 mid = 0.25 count = 193 mid = 0.75 count = 138 mid = 1.25 count = 93 mid = 1.75 count = 43 mid = 2.25 count = 16 mid = 2.75 count = 10 When you first issued the library(BrailleR) command, there were several warnings printed out. One of them told you that the hist() function from the graphics package was masked by the BrailleR version. This means that when you use hist(), it is the BrailleR version being used. 5.3 Scatter plots The description of the hist() function given above shows what is possible if a graph is created using a specific function. Many plots are created using the plot() function which is actually a family of functions tailored to the type of object pushed into them. In addition, the plot() command is used to generate a simple scatter plot. This is slightyly unfortunate in a theoretical sense, but useful in a practical sense. The use of plot() to generate a scatter plot cannot lead to a graph that the VI() functionality can work with. Unlike the hist() command which can be replaced by a function of the same name in the BrailleR package, the solution needs to be a new function of a new name. In addition to the new ScatterPlot() function, the BrailleR package has a FittedLinePlot() function that adds a fitted line to the scatter plot. The example given on the help page for ScatterPlot() proves that the plots generated by ScatterPlot() and FittedLinePlot() are identical to those that would normally be created using plot() and the addition of the fitted line using abline(). Running the command, example(ScatterPlot) command will give you the following: &gt; attach(airquality) &gt; op = par(mfcol = c(3, 2)) &gt; plot(Wind, Ozone, pch = 4) &gt; test1 = ScatterPlot(Wind, Ozone, pch = 4) &gt; test1 &gt; plot(Wind, Ozone) &gt; abline(coef(lm(Ozone ~ Wind)), col = 4) &gt; test2 = FittedLinePlot(Wind, Ozone, line.col = 4) &gt; test2 Figure 5.2: The six graphs generated by the example(ScatterPlot) &gt; par(op) &gt; detach(airquality) &gt; rm(test1) &gt; rm(test2) &gt; rm(op) 5.4 BrailleR commands used in this chapter The BrailleR versions of the hist() and boxplot() commands replace those found in the graphics package. The BrailleR commands ScatterPlot() and FittedLinePlot() are specific to BrailleR and replace the functionality usually obtained through use of plot() and abline(). "],
["RMarkdown.html", "Chapter 6 Use of R markdown to generate an analysis efficiently 6.1 General information 6.2 Description of a single numeric variable 6.3 Analysis of a single continuous variable with respect to a single grouping factor 6.4 Use of BrailleR for linear regression 6.5 Analysis of a single continuous variable with respect to another continuous variable 6.6 BrailleR commands used in this chapter", " Chapter 6 Use of R markdown to generate an analysis efficiently In a general sense, R markdown has been used to create reports and package vignettes because it creates an analysis that is reproducible. The BrailleR package started to use R markdown in late 2014 as a method for generating simple analyses that might be needed by students taking introductory statistics courses. Since that time, the prevalence of R markdown as a teaching tool in these courses has increased. The functions described below are therefore also generating example R markdown files to help learn how to use R markdown. You will need the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the command library(BrailleR) now. 6.1 General information Each command described in this chapter and other similar commands draft a new R markdown file and then compile it to an HTML file that is easily read by a screen reader user. This HTML file is opened automatically if R is being used interactively, giving the blind user immediate access to the information. The content is presented using sufficiently marked up HTML code including headings and tables so that the blind user can make best use of their screen reading software. All graphs, which are given an “alt tag” when they are included in the HTML file, can be presented using a text description available from the VI() functionality of the BrailleR package. In addition, the blind user may need any/all of the graphs in a variety of formats (png, pdf, eps, or svg), nicely formatted tables for insertion into documents (LaTeX or HTML), and access to the code that generated these graphs and tables (an R script). While these commands show the use of R markdown in action, they cannot actually be used within a user’s R markdown document. If you wish to get the output you observe within the HTML documents that will be generated, you will need to extract the relevant parts of the R markdown script files that the commands create. 6.2 Description of a single numeric variable There are many commands needed to get the numeric and graphic summary measures that might be required to collect all relevant information on a single numeric variable. The UniDesc() command has been written as a shortcut for a blind user who wishes to obtain: the counts of points in the sample that were observed and not observed, the mean and trimmed mean, the five number summary: minimum, lower quartile, median, upper quartile, and maximum, the interquartile range (IQR) and standard deviation, measures of skewness and kurtosis (thanks to the moments package), a histogram and/or a boxplot, a normality (quantile-quantile) plot, various tests for normality (thanks to the nortest package), and tests on the significance of the skewness and kurtosis (again, thanks to the moments package). The UniDesc() function can deliver all of this with minimal effort from the user. An example of the main output document (HTML) can be viewed by re-issuing the commands generated by calling example(UniDesc) while running R interactively. This issues the following commands. Ozone=airquality$Ozone UniDesc(Ozone, View=FALSE) rm(Ozone) # N.B. Various files and a folder were created in the working directory. # Please investigate them to see how this function worked. There is one small change to make To get the desired outcome. The argument View=FALSE stops the default action which is to open the HTML document automatically. This avoids problems while the BrailleR package is being created. The UniDesc() function was designed for interactive use so do not include this argument if you do want this function to open the HTML file automatically. As an alternative, and if you do have a current internet connection you can view the result of running the UniDesc() command on the Ozone data in your browser without having to re-enter the example commands. 6.3 Analysis of a single continuous variable with respect to a single grouping factor There are many commands needed to get the numeric and graphic summary measures that might be required to collect all relevant information on a single numeric variable when it might depend on a grouping factor. The OneFactor() command has been written as a shortcut for a blind user who wishes to obtain: the counts of observations within each group, the mean, standard deviation and standard error for each group, comparative boxplots and/or dotplots, the one-way analysis of variance, and Tukey’s Honestly Significant Difference (HSD) test on the significance of the between group differences. An example of the main output document (HTML) can be viewed by re-issuing the commands generated by calling example(OneFactor) while running R interactively. This issues the following commands. data(airquality) # the following line returns an error: ## OneFactor(&quot;Ozone&quot;, &quot;Month&quot;, airquality, View=FALSE) # so we make a copy of the data.frame, and fix that: airquality2 = airquality airquality2$Month = as.factor(airquality$Month) # and now all is good to try: OneFactor(&quot;Ozone&quot;, &quot;Month&quot;, airquality2) # N.B. Various files and a folder were created in the working directory. # Please investigate them to see how this function worked. As before, there is one small change to make To get the desired outcome. The argument View=FALSE which stops the HTML document opening automatically needs to be removed. As an alternative, and if you do have a current internet connection you can view the result of running the OneFactor() command on the Ozone data in your browser without having to re-enter the example commands. The example here demonstrates the point that the grouping variable must be a factor. The month variable is not stored as a factor in the airquality data so its use would have created an error. 6.4 Use of BrailleR for linear regression It is common for sighted users to create a handful of graphs that help them determine the validity of a linear model, even the most basic simple linear regressions. The VI() command can be applied to a linear model object. The specific function to do this is found in the VI.lm()function, but most users do not need to explicitly useVI.lm()because the call toVI()will know to use theVI.lm()` function if it is the right one to use at the time. The VI.lm() function generates so much text as a substitute for the graphs used by sighted users, that it is easier to put this text in an HTML document and have that new document opened in a browser instead of trying to use a screen reader within the R session. Let’s see an example using the airquality data. A simple linear regression model might be created and investigated using: data(airquality) MyModel = lm(Ozone~Temp, data=airquality) summary(MyModel) Call: lm(formula = Ozone ~ Temp, data = airquality) Residuals: Min 1Q Median 3Q Max -40.729 -17.409 -0.587 11.306 118.271 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -146.9955 18.2872 -8.038 9.37e-13 *** Temp 2.4287 0.2331 10.418 &lt; 2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 23.71 on 114 degrees of freedom (37 observations deleted due to missingness) Multiple R-squared: 0.4877, Adjusted R-squared: 0.4832 F-statistic: 108.5 on 1 and 114 DF, p-value: &lt; 2.2e-16 par(mfrow=c(2,2)) plot(MyModel) (#fig:AirQuality.lm)Diagnostic plots for the simple linear regression model. cat(paste(&quot;MyModel = lm(Ozone~Temp, data=airquality, echo=FALSE)&quot;, &quot;VI(MyModel)&quot;, sep=&quot;\\n&quot;), file=&quot;RunLater.R&quot;, append=TRUE) The user now has a model stored as MyModel in the current workspace, has printed a summary of that model, and has plotted a set of four diagnostic plots in a \\(2\\times{}2\\) grid. The blind user will still need to issue those commands so that the output is created to meet the expectations of the sighted audience, but will also find value in issuing the two extra commands VI(MyModel) VI(summary(MyModel)) The use of the second of these commands will generate The term which is significant to 1% is Temp with an estimate of 2.428703 and P-Value of 2.931897e-18 which will be a much easier reading exercise for a screen reader user than would be the standard summary() output given earlier. Note that not all the information contained in the standard summary is contained in this output. The output from use of the VI() command on the linear model can be viewed in your browser if you have a current internet connection. If you do not have a connection at this time, you will need to re-issue some of the above commands for yourself in an R session. 6.5 Analysis of a single continuous variable with respect to another continuous variable The OnePredictor() command is similar to the OneFactor() command describe earlier in this chapter and makes use of the VI() command as applied to the simple linear regression model fitted to a pair of continuous variables, one of which is determined to respond to the other. The OnePredictor() command has been written as a shortcut for a blind user who wishes to obtain: the counts of observations within each group, An example of the main output document (HTML) can be viewed by re-issuing the commands generated by calling example(OnePredictor) while running R interactively. This issues the following commands. data(airquality) OnePredictor(&quot;Ozone&quot;, &quot;Wind&quot;, airquality, View=FALSE) # N.B. Various files and a folder were created in the working directory. # Please investigate them to see how this function worked. As before, there is one small change to make To get the desired outcome. The argument View=FALSE which stops the HTML document opening automatically needs to be removed. As an alternative, and if you do have a current internet connection you can view the result of running the OnePredictor() command on the Ozone data in your browser without having to re-enter the example commands. 6.6 BrailleR commands used in this chapter The first two BrailleR commands introduced in this chapter were the UniDesc() and OneFactor() commands; they used the VI() command in the R markdown files that they create, as was described back in Chapter 4, to give the text descriptions for graphs. We then saw a new use of the VI() command and several other commands designed to generate common analyses quickly. These included the OnePredictor(), etc. "],
["Personalising.html", "Chapter 7 Personalising BrailleR 7.1 General 7.2 Settings that are about you 7.3 Settings for saving 7.4 BrailleR commands used in this chapter", " Chapter 7 Personalising BrailleR 7.1 General Once you’ve played with a few examples, you might want to settle on the way you want BrailleR to work for you. There are a wide range of options needed to get the best out of the BrailleR package specific to each user, and perhaps for each user who wants specific settings to be in play for different projects. All BrailleR settings are stored in a local file, and also in a global file. These files are both called BrailleROptions. The global settings file is located in a folder called MyBrailleR which is located where you let BrailleR choose when you first loaded the package using the library(BrailleR) command. You could have let this be a temporary location so you will be asked every time you start BrailleR until you let the standard location be used. The BrailleROptions file in the MyBrailleR folder will be used unless a local version is found. This local file will be in the working directory being used when the package is loaded. 7.2 Settings that are about you 7.2.1 Who is the R markdown file being written by? You might want your analyses to use your name instead of the default name BrailleR. Do this using the SetAuthor() function. e.g. SetAuthor(&quot;Jonathan Godfrey&quot;) OK, you ought to use your name not mine, but you get the point. This will have an instant impact, even on the examples for BrailleR functions. Set the author and then try example(UniDesc) for example. 7.2.2 The use of the VI() command The BrailleR package was intended for use by blind people, but we need to see more in text than do most people in our intended audiences. You may wish to turn off or on the use of the output generated by the VI() commands throughout the R markdown files written by such commands as UniDesc() etc. Do this using the functions GoBlind() to use the VI() command, and GoSighted() to turn it off. I think a standard workflow might be to start BrailleR, do some analyses using UniDesc() or OnePredictor() and the like, and then having worked out what was working well, use GoSighted() and re-issue the commands that you want to share with others. Don’t forget to GoBlind() again though so that you can get the text descriptions back when you need them. 7.3 Settings for saving 7.4 BrailleR commands used in this chapter SetAuthor(), GoBlind() and GoSighted(), "],
["GGPlot.html", "Chapter 8 The ggplot world and BrailleR 8.1 Plotting a continuous variable against a categorical variable 8.2 time series plots 8.3 path plots 8.4 facets is the ggplot term for trellis’ panels 8.5 rescaling of the axes", " Chapter 8 The ggplot world and BrailleR The use of the ggplot style of graph production has increased markedly since its inception. The grammar of graphics as seen in the R code used to create the extremely wide range of graphs is seldom human-interpretable with ease. Creation of suitable support functionality via the VI() command is very definitely required. An initial attempt to extract any useful infromation from these graphs was contributed to the BrailleR package by Tony Hirst. Significant improvement has been made by Debra Warren as part of her postgraduate work under the supervision of Paul Murrell at the University of Auckland. Much of what is displayed in this chapter is only worth offering because of Debra’s work and the interactions had between her, Paul and I in the second half of 2017. N.B. the commands here are exact copies of the commands presented in Wickham (2009) or some minor alterations to them; any changes will be explicitly noted. All plots are created using the figure numbers from Wickham (2009) or the page numbers if no figure number was given. They are then investigated using the VI() command from the BrailleR package. You will need some additional packages to the BrailleR package to be ready for use to follow along with the examples in this chapter. Do this by issuing the commands: library(BrailleR) library(ggplot2) Attaching package: &#39;ggplot2&#39; The following objects are masked from &#39;package:BrailleR&#39;: xlab, ylab library(magrittr) Note that one data set used for these examples is created by Wickham (2009) while the others are included in the ggplot2 package. set.seed(1410) dsmall &lt;- diamonds[sample(nrow(diamonds), 100),] One important note for the graphs in this chapter is the difference in the way they appear here, as compared to the original figures of Wickham (2009) where differing height and width parameters have been set for each graph. For example, in the following graph, the points are smaller than in the original figure, and the aspect ratio is slightly different. The consequence is that this graph looks less cluttered than does the original. p11a = qplot(carat, price, data = diamonds) p11a Figure 8.1: First graph on page 11 of Wickham (2009) VI(p11a) This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. The chart is a set of 53940 points. Note that unlike some other ways the VI() command has worked, the graph was not created by the nesting of the call to render the graph when nested inside the VI() command. In all the examples that follow, I use the pipe %&gt;% operator from the magrittr package to push the graph into the VI() function. fig2.2a = qplot(carat, price, data = dsmall, colour = color) fig2.2a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.5, 1.0, 1.5, 2.0 and 2.5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. There is a legend indicating that colour is used to represent color, with 7 levels: D represented by colour strong reddish orange, E represented by colour strong yellow, F represented by colour vivid yellowish green, G represented by colour brilliant green, H represented by colour brilliant blue, I represented by colour vivid violet and J represented by colour deep purplish pink. The chart is a set of 100 points. fig2.2a Figure 8.2: Left pane of Figure 2.2 of Wickham (2009) We haven’t been able to tell what exact colour was used in the Wickham (2009) rendering of this graph, but there has obviously been some minor alteration of the colour palette being used by the ggplot2 package. fig2.2b = qplot(carat, price, data = dsmall, shape = cut) fig2.2b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.5, 1.0, 1.5, 2.0 and 2.5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. There is a legend indicating that shape is used to represent cut, with 5 levels: Fair represented by shape solid circle, Good represented by shape solid triangle, Very Good represented by shape solid square, Premium represented by shape plus and Ideal represented by shape boxed X. The chart is a set of 100 points. fig2.2b Figure 8.3: Right pane of Figure 2.2 To get semi-transparent points: fig2.3b = qplot(carat, price, data = diamonds, alpha = I(1/100)) fig2.3b Figure 8.4: Middle pane from Figure 2.3 fig2.3b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000 and 15000. The chart is a set of 53940 points. The chart has alpha set to 0.01. To add a smoother (default is loess for n&lt;1000): fig2.4a = qplot(carat, price, data = dsmall, geom = c(&quot;point&quot;, &quot;smooth&quot;)) fig2.4a `geom_smooth()` using method = &#39;loess&#39; Figure 8.5: Left pane of Figure 2.4 fig2.4a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0.5, 1.0, 1.5, 2.0 and 2.5. It has y-axis &#39;price&#39; with labels 0, 5000, 10000, 15000 and 20000. It has 2 layers. Layer 1 is a set of 100 points. Layer 2 is a smoothed curve using method &#39;auto&#39; with confidence intervals. 8.1 Plotting a continuous variable against a categorical variable fig2.8a = qplot(color, price / carat, data = diamonds, geom = &quot;jitter&quot;) fig2.8a Figure 8.6: Left pane of Figure 2.8 fig2.8a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;price/carat&#39; with labels 5000, 10000 and 15000. The chart is a set of 53940 points. fig2.8b = qplot(color, price / carat, data = diamonds, geom = &quot;boxplot&quot;) fig2.8b fig2.8b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;price/carat&#39; with labels 5000, 10000 and 15000. The chart is a boxplot comprised of 7 boxes with whiskers. There is a box at x=D. It has median 3410.53. The box goes from 2455 to 4749.31, and the whiskers extend to 1128.12 and 8183.33. There are 338 outliers for this boxplot. There is a box at x=E. It has median 3253.66. The box goes from 2430.3 to 4508.41, and the whiskers extend to 1078.12 and 7616.39. There are 593 outliers for this boxplot. There is a box at x=F. It has median 3494.32. The box goes from 2587.1 to 4947.22, and the whiskers extend to 1168 and 8477.5. There are 585 outliers for this boxplot. There is a box at x=G. It has median 3490.38. The box goes from 2538.24 to 5500, and the whiskers extend to 1139.02 and 9937.2. There are 119 outliers for this boxplot. There is a box at x=H. It has median 3818.89. The box goes from 2396.88 to 5127.28, and the whiskers extend to 1051.16 and 9220. There are 13 outliers for this boxplot. There is a box at x=I. It has median 3779.74. The box goes from 2344.65 to 5196.75, and the whiskers extend to 1151.72 and 9397.5. There are 0 outliers for this boxplot. There is a box at x=J. It has median 3780. The box goes from 2562.87 to 4927.95, and the whiskers extend to 1080.65 and 8426.13. There are 3 outliers for this boxplot. When seeking to use shading or opaqueness to describe the density of the points, the fact the size of the points has an impact on the opaqueness is not realised by BrailleR. fig2.9b = qplot(color, price / carat, data = diamonds, geom = &quot;jitter&quot;, alpha = I(1 / 50)) fig2.9b Figure 8.7: Middle pane of Figure 2.9 fig2.9b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;price/carat&#39; with labels 5000, 10000 and 15000. The chart is a set of 53940 points. The chart has alpha set to 0.02. 8.1.1 univariate plots fig2.10a = qplot(carat, data = diamonds, geom = &quot;histogram&quot;) fig2.10a `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 8.8: Left pane of Figure 2.10 fig2.10a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;count&#39; with labels 0, 5000, 10000 and 15000. The chart is a bar chart containing 30 vertical bars. Warning: This figure does look different to the original in Wickham (2009) ins spite of using the same code and same data. fig2.10b = qplot(carat, data = diamonds, geom = &quot;density&quot;) fig2.10b Figure 8.9: Right pane of Figure 2.10 fig2.10b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;density&#39; with labels 0.0, 0.5, 1.0 and 1.5. The chart is a type that VI isn&#39;t able to process. fig2.11c = qplot(carat, data = diamonds, geom = &quot;histogram&quot;, binwidth = 0.01, xlim = c(0,3)) fig2.11c Warning: Removed 32 rows containing non-finite values (stat_bin). Figure 8.10: Right pane of Figure 2.11 fig2.11c %&gt;% VI() Warning: Removed 32 rows containing non-finite values (stat_bin). This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2 and 3. It has y-axis &#39;count&#39; with labels 0, 1000 and 2000. The chart is a bar chart containing 299 vertical bars. The data is separated by implication in the following graphs. The legend is automatically generated and has altered in appearance since the original was prodcued in Wickham (2009). fig2.12a = qplot(carat, data = diamonds, geom = &quot;density&quot;, colour = color) fig2.12a Figure 8.11: Left pane of Figure 2.12 fig2.12a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;density&#39; with labels 0.0, 0.5, 1.0, 1.5 and 2.0. There is a legend indicating that colour is used to represent color, with 7 levels: D represented by colour strong reddish orange, E represented by colour strong yellow, F represented by colour vivid yellowish green, G represented by colour brilliant green, H represented by colour brilliant blue, I represented by colour vivid violet and J represented by colour deep purplish pink. The chart is a type that VI isn&#39;t able to process. fig2.12b = qplot(carat, data = diamonds, geom = &quot;histogram&quot;, fill = color) fig2.12b `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Figure 8.12: Right pane of Figure 2.12 fig2.12b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 0, 1, 2, 3, 4 and 5. It has y-axis &#39;count&#39; with labels 0, 5000, 10000 and 15000. There is a legend indicating that fill is used to represent color, with 7 levels: D represented by fill #F8766D, E represented by fill #C49A00, F represented by fill #53B400, G represented by fill #00C094, H represented by fill #00B6EB, I represented by fill #A58AFF and J represented by fill #FB61D7. The chart is a bar chart containing 210 vertical bars. 8.1.2 bar charts for categorical variables fig2.13a = qplot(color, data = diamonds, geom = &quot;bar&quot;) #geom=&quot;bar&quot; is the default fig2.13a Figure 8.13: Left pane of Figure 2.13 fig2.13a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;count&#39; with labels 0, 3000, 6000 and 9000. The chart is a bar chart containing 7 vertical bars. Bar 1 is centered horizontally at D, and spans vertically from 0 to 6775. Bar 2 is centered horizontally at E, and spans vertically from 0 to 9797. Bar 3 is centered horizontally at F, and spans vertically from 0 to 9542. Bar 4 is centered horizontally at G, and spans vertically from 0 to 11292. Bar 5 is centered horizontally at H, and spans vertically from 0 to 8304. Bar 6 is centered horizontally at I, and spans vertically from 0 to 5422. Bar 7 is centered horizontally at J, and spans vertically from 0 to 2808. need to check… fig2.13b = qplot(color, data = diamonds, geom = &quot;bar&quot;, weight = carat) fig2.13b Figure 8.14: Right pane of Figure 2.13 fig2.13b = qplot(color, data = diamonds, geom = &quot;bar&quot;, weight = carat) + scale_y_continuous(&quot;carat&quot;) fig2.13b Figure 8.14: Right pane of Figure 2.13 fig2.13b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;color&#39; with labels D, E, F, G, H, I and J. It has y-axis &#39;count&#39; with labels 0, 2500, 5000 and 7500. The chart is a bar chart containing 7 vertical bars. Bar 1 is centered horizontally at D, and spans vertically from 0 to 4456.56. Bar 2 is centered horizontally at E, and spans vertically from 0 to 6445.12. Bar 3 is centered horizontally at F, and spans vertically from 0 to 7028.05. Bar 4 is centered horizontally at G, and spans vertically from 0 to 8708.28. Bar 5 is centered horizontally at H, and spans vertically from 0 to 7571.58. Bar 6 is centered horizontally at I, and spans vertically from 0 to 5568. Bar 7 is centered horizontally at J, and spans vertically from 0 to 3263.28. 8.2 time series plots It looks like the data used in the next graph has been updated since the publication of Wickham (2009) fig2.14a = qplot(date, unemploy / pop, data = economics, geom = &quot;line&quot;) fig2.14a Figure 8.15: Left pane of Figure 2.14 fig2.14a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;date&#39; with labels 1970, 1980, 1990, 2000 and 2010. It has y-axis &#39;unemploy/pop&#39; with labels 0.02, 0.03, 0.04 and 0.05. The chart is a set of 1 line. Line 1 connects 574 points. 8.3 path plots year &lt;- function(x) as.POSIXlt(x)$year + 1900 fig2.15b = qplot(unemploy / pop, uempmed, data = economics, geom = &quot;path&quot;, colour=year(date)) #+ scale_area() # no longer works fig2.15b Figure 8.16: Right pane of Figure 2.15 fig2.15b %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;unemploy/pop&#39; with labels 0.02, 0.03, 0.04 and 0.05. It has y-axis &#39;uempmed&#39; with labels 5, 10, 15, 20 and 25. There is a legend indicating that colour is used to represent year(date), ranging from 1967 represented by colour dark purplish blue to 2015 represented by colour brilliant blue. The chart is a type that VI isn&#39;t able to process. 8.4 facets is the ggplot term for trellis’ panels The aspect ratio for the plot region is something that needs to be considered. I’ve manually adjusted the plotting window here so that the graph more closely matches that of Wickham (2009) but it is not an exact match. fig2.16a = qplot(carat, data = diamonds, facets = color ~ ., geom = &quot;histogram&quot;, binwidth = 0.1, xlim = c(0, 3)) fig2.16a Warning: Removed 32 rows containing non-finite values (stat_bin). Figure 8.17: Left side of Figure 2.16 fig2.16a %&gt;% VI() Warning: Removed 32 rows containing non-finite values (stat_bin). This is an untitled chart with no subtitle or caption. The chart is comprised of 7 panels containing sub-charts, arranged vertically. The panels represent different values of color. Each sub-chart has x-axis &#39;carat&#39; with labels 0, 1, 2 and 3. Each sub-chart has y-axis &#39;count&#39; with labels 0, 500, 1000, 1500, 2000 and 2500. Panel 1 represents data for color = D. Panel 1 is a bar chart containing 29 vertical bars. Panel 2 represents data for color = E. Panel 2 is a bar chart containing 29 vertical bars. Panel 3 represents data for color = F. Panel 3 is a bar chart containing 29 vertical bars. Panel 4 represents data for color = G. Panel 4 is a bar chart containing 29 vertical bars. Panel 5 represents data for color = H. Panel 5 is a bar chart containing 29 vertical bars. Panel 6 represents data for color = I. Panel 6 is a bar chart containing 29 vertical bars. Panel 7 represents data for color = J. Panel 7 is a bar chart containing 29 vertical bars. fig2.16b = qplot(carat, ..density.., data = diamonds, facets = color ~ ., geom = &quot;histogram&quot;, binwidth = 0.1, xlim = c(0, 3)) fig2.16b Warning: Removed 32 rows containing non-finite values (stat_bin). Figure 8.18: Right side of Figure 2.16 fig2.16b %&gt;% VI() Warning: Removed 32 rows containing non-finite values (stat_bin). This is an untitled chart with no subtitle or caption. The chart is comprised of 7 panels containing sub-charts, arranged vertically. The panels represent different values of color. Each sub-chart has x-axis &#39;carat&#39; with labels 0, 1, 2 and 3. Each sub-chart has y-axis &#39;density&#39; with labels 0.0, 0.5, 1.0, 1.5 and 2.0. Panel 1 represents data for color = D. Panel 1 is a bar chart containing 29 vertical bars. Panel 2 represents data for color = E. Panel 2 is a bar chart containing 29 vertical bars. Panel 3 represents data for color = F. Panel 3 is a bar chart containing 29 vertical bars. Panel 4 represents data for color = G. Panel 4 is a bar chart containing 29 vertical bars. Panel 5 represents data for color = H. Panel 5 is a bar chart containing 29 vertical bars. Panel 6 represents data for color = I. Panel 6 is a bar chart containing 29 vertical bars. Panel 7 represents data for color = J. Panel 7 is a bar chart containing 29 vertical bars. 8.5 rescaling of the axes p26a = qplot(carat, price, data = dsmall, log = &quot;xy&quot;) p26a Figure 8.19: First graph on page 26 of p26a %&gt;% VI() This is an untitled chart with no subtitle or caption. It has x-axis &#39;carat&#39; with labels 1. It has y-axis &#39;price&#39; with labels 1000 and 10000. The chart is a set of 100 points. fig3.6 = qplot(displ, hwy, data=mpg, facets =~ year) + geom_smooth() fig3.6 `geom_smooth()` using method = &#39;loess&#39; Figure 8.20: Figure 3.6 of fig3.6 %&gt;% VI() This is an untitled chart with no subtitle or caption. The chart is comprised of 2 panels containing sub-charts, arranged horizontally. The panels represent different values of year. Each sub-chart has x-axis &#39;displ&#39; with labels 2, 3, 4, 5, 6 and 7. Each sub-chart has y-axis &#39;hwy&#39; with labels 20, 30 and 40. Each sub-chart has 2 layers. Panel 1 represents data for year = 1999. Layer 1 of panel 1 is a set of 117 points. Layer 2 of panel 1 is a smoothed curve using method &#39;auto&#39; with confidence intervals. Panel 2 represents data for year = 2008. Layer 1 of panel 2 is a set of 117 points. Layer 2 of panel 2 is a smoothed curve using method &#39;auto&#39; with confidence intervals. References "],
["WriteR.html", "Chapter 9 Getting started with the WriteR application 9.1 Getting Python and wxPython (Windows users only) 9.2 Opening WriteR from BrailleR 9.3 What can I do with WriteR? 9.4 Our first HTML file 9.5 BrailleR commands used in this chapter", " Chapter 9 Getting started with the WriteR application The WriteR application was written to support use of R markdown and the BrailleR package. It is a Python script making use of wxPython to help build the graphic user interface (GUI) in such a way that it works for screen reader users. This book has been written in R markdown, and the author has made extensive use of WriteR because it offers so many convenient tools for a blind user wanting to write R markdown files. The script is in the BrailleR package, but it cannot run unless the user has both Python and wxPython installed. Two commands have been included in the BrailleR package to help Windows users obtain installation files for them. Users of other operating systems currently have to install Python and WxPython independently. 9.1 Getting Python and wxPython (Windows users only) Issue the following commands at the R prompt library(BrailleR) GetPython27() GetWxPython27() These commands automatically download the installation files and start the installation process going. The downloaded files will be saved in your MyBrailleR folder. You will need to follow the instructions and answer questions that arise whenever you install new software. These are reputable installation files from the primary sites for Python and wxPython. Windows and any security software you might have should know that, but you can never tell! You will probably need to let Windows know it is OK to install the software in the default location. That pop-up might not appear as the window with focus so if things look like they’re going slowly, look around for the pop-up window. Once you have completed both installations, you are ready to go. You shouldn’t need those installation files again, but keep them just in case. 9.2 Opening WriteR from BrailleR Opening WriteR is as easy as typing WriteR! Well almost. You have the option of specifying a filename; if that file exists, it gets opened for you, and if it doesn’t exist, then it gets created with a few lines already included at the top to help get you started. Try: WriteR(&quot;MyFirst.Rmd&quot;) 9.3 What can I do with WriteR? The window you are in has a number of menus, a status bar at the bottom and a big space in the middle for your work. Take a quick look at those menus; some will look familiar because they are common to many Windows applications. The file you have open is a markdown file. It is just text which is why it is so easy to read. The file extension of Rmd means it is an R markdown file. There are several flavours of markdown in common use, but they are practically all the same except for some very minor differences. A markdown file can be converted into many file formats for distribution. These include HTML, pdf, Microsoft Word, Open Office, and a number of different slide presentation formats. Let’s make the HTML file now. 9.4 Our first HTML file Making your first HTML file is as easy as hitting a single key, or using one of the options in the Build menu. The variety of options are the commonly used ones in RStudio. Navigate to the current working directory using your file browser. To find out where that is, type getwd() back in the R window. You should see the file MyFirst.Rmd and once you have built it, the associated HTML file. Open the HTML file and see how the markdown has been rendered. You may need to switch back and forth between the WriteR window and your browser to compare the plain text and the beautiful HTML. 9.5 BrailleR commands used in this chapter We needed to use GetPython27() and GetWxPython27() to install the necessary software to allow us to run a Python script like WriteR. We then opened a new file using WriteR(). "],
["references-3.html", "Chapter 10 References", " Chapter 10 References "]
]
